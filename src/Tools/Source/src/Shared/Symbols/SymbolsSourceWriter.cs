// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using Microsoft.CodeAnalysis;
using Luna.Compilers.Generators.CSharp;
using Luna.Compilers.Generators.Model;
using Luna.Compilers.Generators.Symbols.Model;
using Qtyi.CodeAnalysis;
using LanguageNames = Qtyi.CodeAnalysis.LanguageNames;

namespace Luna.Compilers.Generators.Symbols;

internal class SymbolsSourceWriter : SymbolsFileWriter
{
    private SymbolsSourceWriter(TextWriter writer, SymbolTree tree, CancellationToken cancellationToken) : base(writer, tree, cancellationToken) { }

    public static void WriteInternal(TextWriter writer, SymbolTree tree, Compilation _, CancellationToken cancellationToken = default) => new SymbolsSourceWriter(writer, tree, cancellationToken).WriteInternal();

    public static void WritePublic(TextWriter writer, SymbolTree tree, Compilation _, CancellationToken cancellationToken = default) => new SymbolsSourceWriter(writer, tree, cancellationToken).WritePublic();

    private void WriteFileHeader()
    {
        this.WriteLine("// <auto-generated />");
        this.WriteLine();
        this.WriteLine("#nullable enable");
        this.WriteLine();
        this.WriteLine("using System;");
        this.WriteLine("using System.Collections.Generic;");
        this.WriteLine("using Microsoft.CodeAnalysis;");
        this.WriteLine("using Microsoft.CodeAnalysis.Symbols;");
        this.WriteLine($"using Qtyi.CodeAnalysis.{LanguageNames.This};");
        this.WriteLine($"using Qtyi.CodeAnalysis.{LanguageNames.This}.Symbols;");
        this.WriteLine("using Roslyn.Utilities;");
        this.WriteLine();
    }

    #region 内部源代码
    private void WriteInternal()
    {
        this.WriteFileHeader();
        this.WriteLine($"namespace Qtyi.CodeAnalysis.{LanguageNames.This}.Symbols");
        this.OpenBlock();
        this.WriteInternalSymbols();
        this.CloseBlock();

        this.WriteLine();
        this.WriteLine($"namespace Qtyi.CodeAnalysis.{LanguageNames.This}");
        this.OpenBlock();
        this.WriteInternalVisitors();
        this.CloseBlock();
    }

    private void WriteInternalSymbols()
    {
        var symbols = this.Tree.Types.Where(n => n is not PredefinedSymbol).ToList();
        foreach (var symbol in symbols)
        {
            this.WriteLine();
            this.WriteInternalSymbol(symbol);
        }
    }

    private void WriteInternalSymbol(SymbolTreeType symbol)
    {
        if (symbol is AbstractSymbol or Symbol)
        {
            bool isSealed = symbol is Symbol && ((Symbol)symbol).Sealed.IsTrue();
            this.WriteLine($"internal {(isSealed ? "sealed" : "abstract")} partial class {symbol.Name} : {symbol.Base}");
            this.OpenBlock();

            this.WriteInternalAcceptMethods(symbol);

            this.CloseBlock();
        }
    }

    private void WriteInternalAcceptMethods(SymbolTreeType symbol)
    {
        if (symbol is AbstractSymbol) return;

        this.WriteLine();
        this.WriteLine($"public override void Accept({LanguageNames.This}SymbolVisitor visitor) => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        this.WriteLine($"public override TResult? Accept<TResult>({LanguageNames.This}SymbolVisitor<TResult> visitor) where TResult : default => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        this.WriteLine($"internal override TResult? Accept<TArgument, TResult>({LanguageNames.This}SymbolVisitor<TArgument, TResult> visitor, TArgument argument) where TResult : default => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this, argument);");
    }

    private void WriteInternalVisitors()
    {
        this.WriteInternalVisitor(withResult: false);
        this.WriteInternalVisitor(withResult: true, withArgument: false);
        this.WriteInternalVisitor(withResult: true, withArgument: true);
    }

    private void WriteInternalVisitor(bool withResult, bool withArgument = false)
    {
        var symbols = Tree.Types.Where(n => n is not PredefinedSymbol).ToList();

        this.WriteLine();
        this.WriteLine($"partial class {LanguageNames.This}SymbolVisitor{(withResult ? (withArgument ? "<TArgument, TResult>" : "<TResult>") : "")}");
        this.OpenBlock();
        foreach (var symbol in symbols.OfType<Symbol>())
        {
            this.WriteLine($"public virtual {(withResult ? "TResult?" : "void")} Visit{StripPost(symbol.Name, "Symbol")}({symbol.Name} symbol{(withArgument ? ", TArgument argument" : "")}) => this.DefaultVisit(symbol{(withArgument ? ", argument" : "")});");
        }
        this.CloseBlock();
    }
    #endregion

    #region 公共源代码
    private void WritePublic()
    {
        this.WriteFileHeader();
        this.WriteLine($"namespace Qtyi.CodeAnalysis.{LanguageNames.This}.Symbols.PublicModel");
        this.OpenBlock();
        this.WritePublicSymbols();
        //this.WritePublicVisitors();
        this.CloseBlock();
    }

    private void WritePublicSymbols()
    {
        var symbols = this.Tree.Types.Where(n => n is not PredefinedSymbol).ToList();
        foreach (var symbol in symbols)
        {
            this.WriteLine();
            this.WritePublicSymbol(symbol);
        }
    }

    private void WritePublicSymbol(SymbolTreeType symbol)
    {
        if (symbol is AbstractSymbol)
        {
            this.WriteLine($"internal abstract partial class {symbol.Name} : {symbol.Base}");
        }
        else if (symbol is Symbol)
        {
            this.WriteLine($"internal sealed partial class {symbol.Name} : {symbol.Base}");
        }
        else return;
        this.OpenBlock();

        //this.WritePublicAcceptMethods(symbol);

        this.CloseBlock();
    }

    private void WritePublicAcceptMethods(SymbolTreeType symbol)
    {
        if (symbol is AbstractSymbol) return;

        this.WriteLine();
        this.WriteLine($"protected override void Accept(SymbolVisitor visitor) => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        this.WriteLine($"protected override TResult Accept<TResult>(SymbolVisitor<TResult> visitor) => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        this.WriteLine($"protected override TResult Accept<TArgument, TResult>(SymbolVisitor<TArgument, TResult> visitor, TArgument argument) => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this, argument);");
    }

    private void WritePublicVisitors()
    {
        this.WritePublicVisitor(withResult: false);
        this.WritePublicVisitor(withResult: true, withArgument: false);
        this.WritePublicVisitor(withResult: true, withArgument: true);
    }

    private void WritePublicVisitor(bool withResult, bool withArgument = false)
    {
        var symbols = Tree.Types.Where(n => n is not PredefinedSymbol).ToList();

        this.WriteLine();
        this.WriteLine($"partial class {LanguageNames.This}SymbolVisitor{(withResult ? "<TResult>" : (withArgument ? "<TArgument, TResult>" : ""))} : SymbolVisitor{(withResult ? (withArgument ? "<TArgument, TResult>" : "<TResult>") : "")}");
        this.OpenBlock();
        foreach (var symbol in symbols.OfType<Symbol>())
        {
            this.WriteLine($"public sealed override {(withResult ? "TResult" : "void")} Visit{StripPost(symbol.Name, "Symbol")}(I{symbol.Name} symbol{(withArgument ? ", TArgument argument" : "")}) => symbol is {symbol.Name} {CamelCase(symbol.Name)} ? this.Visit{StripPost(symbol.Name, "Symbol")}({CamelCase(symbol.Name)}{(withArgument ? ", argument" : "")}) : this.DefaultVisit(symbol{(withArgument ? ", argument" : "")});");
            this.WriteLine($"public virtual {(withResult ? "TResult" : "void")} Visit{StripPost(symbol.Name, "Symbol")}({symbol.Name} symbol{(withArgument ? ", TArgument argument" : "")}) => this.DefaultVisit(symbol{(withArgument ? ", argument" : "")});");
        }
        this.CloseBlock();
    }
    #endregion
}
