// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Collections.Immutable;
using System.Text.RegularExpressions;
using Roslyn.Utilities;
using Luna.Compilers.Generators.Syntax.Model;
using LanguageNames = Qtyi.CodeAnalysis.LanguageNames;
using System;

#if LANG_LUA
using SyntaxFacts = Qtyi.CodeAnalysis.Lua.SyntaxFacts;
using SyntaxKind = Qtyi.CodeAnalysis.Lua.SyntaxKind;
#elif LANG_MOONSCRIPT
using SyntaxFacts = Qtyi.CodeAnalysis.MoonScript.SyntaxFacts;
using SyntaxKind = Qtyi.CodeAnalysis.MoonScript.SyntaxKind;
#endif

namespace Luna.Compilers.Generators;

internal sealed class GrammarWriter : TreeFileWriter<SyntaxTree, SyntaxTreeType>
{
    private readonly Dictionary<string, List<Production>> _rules;
    private readonly string[] _lexicalRules;

    // Define a few major sections to help keep the grammar file naturally grouped.
    private readonly string[] _majorRules = new[]
    {
        "ChunkSyntax", "NameSyntax", "ExpressionSyntax", "StatementSyntax", "StructuredTriviaSyntax"
    };

    public GrammarWriter(TextWriter writer, SyntaxTree tree, CancellationToken cancellationToken) : base(writer, 2, tree, cancellationToken)
    {
        var types = this.Tree.Types;
        this._rules = types.ToDictionary(n => n.Name, _ => new List<Production>());
        foreach (var type in types)
        {
            if (type.Base is not null && this._rules.TryGetValue(type.Base, out var productions))
                productions.Add(RuleReference(type.Name));

            if (type is Node && type.Children.Count > 0)
            {
                // Convert rules like `a: (x | y) ...` into:
                //
                // a: x ...
                //  | y ...;
                //
                // Note: if we have `a: (a1 | b1) ... (ax | bx) presume that that's a paired construct and generate:
                //
                // a: a1 ... ax
                //  | b1 ... bx;

                if (type.Children[0] is Field firstField && firstField.Kinds.Count > 0)
                {
                    var originalFirstFieldKinds = firstField.Kinds.ToList();
                    if (type.Children.Count >= 2 && type.Children[^1] is Field lastField && lastField.Kinds.Count == firstField.Kinds.Count)
                    {
                        var originalLastFieldKinds = lastField.Kinds.ToList();
                        for (int i = 0; i < originalFirstFieldKinds.Count; i++)
                        {
                            firstField.Kinds = new List<Kind> { originalFirstFieldKinds[i] };
                            lastField.Kinds = new List<Kind> { originalLastFieldKinds[i] };
                            this._rules[type.Name].Add(HandleChildren(type.Children));
                        }
                    }
                    else
                    {
                        for (int i = 0; i < originalFirstFieldKinds.Count; i++)
                        {
                            firstField.Kinds = new List<Kind> { originalFirstFieldKinds[i] };
                            this._rules[type.Name].Add(HandleChildren(type.Children));
                        }
                    }
                }
                else
                {
                    this._rules[type.Name].Add(HandleChildren(type.Children));
                }
            }
        }

        // The grammar will bottom out with certain lexical productions. Create rules for these.
        this._lexicalRules = this._rules.Values.SelectMany(ps => ps).SelectMany(p => p.ReferencedRules)
            .Where(r => !this._rules.TryGetValue(r, out var productions) || productions.Count == 0).ToArray();
        foreach (var name in this._lexicalRules)
            this._rules[name] = new List<Production> { new Production("/* see lexical specification */") };
    }

    public static void WriteFile(TextWriter writer, SyntaxTree tree, Microsoft.CodeAnalysis.Compilation _, CancellationToken cancellationToken) => new GrammarWriter(writer, tree, cancellationToken).WriteFile();

    private void WriteFile()
    {
        this.WriteLine("// <auto-generated />");
        this.WriteLine($"grammar {LanguageNames.This.ToLowerInvariant()};");

        // Handle each major section first and then walk any rules not hit transitively from them.
        var seen = new HashSet<string>();
        foreach (var rule in this._majorRules.Concat(this._rules.Keys.OrderBy(static a => a)))
            this.WriteRule(rule, seen);
    }

    private void WriteRule(string name, HashSet<string> seen)
    {
        if (!name.IsNode() && seen.Add(name))
        {
            this.WriteLine();
            this.WriteLine(RuleReference(name).Text);
            this.Indent();

            // Order the productions to keep us independent from whatever changes happen in Syntax.xml.
            var sorted = this._rules[name].OrderBy(v => v);
            var flag = true;
            foreach (var rule in sorted)
            {
                if (flag)
                {
                    this.Write(": ");
                    flag = false;
                }
                else
                    this.Write("| ");

                this.WriteLine(rule.Text);
            }
            this.WriteLine(';');

            this.Unindent();

            // Now proceed in depth-first fashion through the referenced rules to keep related rules close by.
            // Don't recurse into major-sections to help keep them separated in grammar file.
            foreach (var production in sorted)
            {
                foreach (var referencedRule in production.ReferencedRules)
                {
                    if (!this._majorRules.Concat(this._lexicalRules).Contains(referencedRule))
                        WriteRule(referencedRule, seen);
                }
            }
        }
    }

    private static Production Join(string delim, IEnumerable<Production> productions)
        => new(
            string.Join(delim, productions.Where(static p => p.Text.Length > 0)),
            productions.SelectMany(static p => p.ReferencedRules));

    private static Production HandleChildren(IEnumerable<SyntaxTreeTypeChild> children, string delim = " ")
        => Join(delim, children.Select(child =>
            child switch
            {
                Choice c => HandleChildren(c.Children, delim: " | ").Parenthesize(),
                Sequence s => HandleChildren(s.Children).Parenthesize(),
                Field f => HandleField(f).Suffix("?", when: f.IsOptional()),

                _ => throw ExceptionUtilities.UnexpectedValue(child)
            }));

    private static Production HandleField(Field field)
        // 'bool' fields are for a few properties we generate on DirectiveTrivia. They're not
        // relevant to the grammar, so we just return an empty production to ignore them.
        => field switch
        {
            { Type: "bool" } => new Production(""),
            { IsNode: true } => RuleReference(field.Kinds.Single().Name + "Syntax"),
            { IsToken: true } => HandleTokenField(field),
            { IsNodeList: true } => HandleList(field, field.Type[("SyntaxList".Length + 1)..^1]),
            { IsSeparatedNodeList: true } => HandleSeparatedList(field, field.Type[("SeparatedSyntaxList".Length + 1)..^1]),
            _ => RuleReference(field.Type)
        };

    private static Production HandleSeparatedList(Field field, string elementType)
        => RuleReference(elementType).Suffix(" (',' " + RuleReference(elementType) + ")")
            .Suffix("*", when: field.MinCount < 2).Suffix("+", when: field.MinCount >= 2)
            .Suffix(" ','?", when: field.AllowTrailingSeparator)
            .Parenthesize(when: field.MinCount == 0).Suffix("?", when: field.MinCount == 0);

    private static Production HandleList(Field field, string elementType)
        => (elementType.IsToken() ? RuleReference(elementType) :
            field.Name == "Commas" ? new Production("','") :
            RuleReference(elementType))
                .Suffix(field.MinCount == 0 ? "*" : "+");

    private static Production HandleTokenField(Field field)
        => field.Kinds.Count == 0
            ? HandleTokenName(field.Name)
            : Join(" | ", field.Kinds.Select(k => HandleTokenName(k.Name))).Parenthesize(when: field.Kinds.Count >= 2);

    private static Production HandleTokenName(string tokenName)
        => GetSyntaxKind(tokenName) is var kind && kind == SyntaxKind.None ? RuleReference("SyntaxToken") :
           SyntaxFacts.GetText(kind) is var text && text != "" ? new Production(text == "'" ? "'\\''" : $"'{text}'") :
           tokenName.StartsWith("EndOf") ? new Production("") :
           tokenName.StartsWith("Omitted") ? new Production("/* epsilon */") : RuleReference(tokenName);

    private static SyntaxKind GetSyntaxKind(string name)
        => ((SyntaxKind[])Enum.GetValues(typeof(SyntaxKind))).Where(k => k.ToString() == name).SingleOrDefault();

    private static Production RuleReference(string name)
        => new(SnakeCase(StripPost(name, "Syntax")),
            ImmutableArray.Create(name));
}

internal readonly struct Production : IComparable<Production>
{
    public readonly string Text;
    public readonly ImmutableArray<string> ReferencedRules;

    public Production(string text, IEnumerable<string>? referencedRules = null)
    {
        this.Text = text;
        this.ReferencedRules = referencedRules.ToImmutableArrayOrEmpty();
    }

    public override readonly string ToString() => this.Text;
    public readonly int CompareTo(Production other) => StringComparer.Ordinal.Compare(this.Text, other.Text);
    public readonly Production Prefix(string prefix) => new(prefix + this.Text, this.ReferencedRules);
    public readonly Production Suffix(string suffix, bool when = true) => when ? new(this.Text + suffix, this.ReferencedRules) : this;
    public readonly Production Parenthesize(bool when = true) => when ? new("(" + this.Text + ")", this.ReferencedRules) : this;
}
