// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using Luna.Compilers.Generators.CSharp;
using Luna.Compilers.Generators.Syntax;
using Luna.Compilers.Generators.Syntax.Model;

namespace Luna.Compilers.Generators;

internal class TestWriter : SyntaxFileWriter
{
    private TestWriter(TextWriter writer, SyntaxTree tree, CancellationToken cancellationToken) : base(writer, tree, cancellationToken) { }

    public static void Write(TextWriter writer, SyntaxTree tree, Microsoft.CodeAnalysis.Compilation _, CancellationToken cancellationToken) => new TestWriter(writer, tree, cancellationToken).WriteFile();

    private void WriteFile()
    {
        this.WriteLine("// <auto-generated />");
        this.WriteLine();
        this.WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
        this.WriteLine("using Roslyn.Utilities;");
        this.WriteLine("using Xunit;");
        this.WriteLine("using InternalSyntaxFactory = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory;");
        this.WriteLine();

        this.WriteLine("namespace Microsoft.CodeAnalysis.CSharp.UnitTests");
        this.OpenBlock();

        this.WriteLine();
        this.WriteLine("public partial class GreenNodeTests");
        this.OpenBlock();

        this.WriteLine("#region Green Generators");
        this.WriteNodeGenerators(isGreen: true);
        this.WriteLine("#endregion Green Generators");
        this.WriteLine();

        this.WriteLine("#region Green Factory and Property Tests");
        this.WriteFactoryPropertyTests(isGreen: true);
        this.WriteLine("#endregion Green Factory and Property Tests");
        this.WriteLine();

        this.WriteLine("#region Green Rewriters");
        this.WriteRewriterTests();
        this.WriteLine("#endregion Green Rewriters");

        this.CloseBlock();

        this.WriteLine();
        this.WriteLine("public partial class RedNodeTests");
        this.OpenBlock();

        this.WriteLine("#region Red Generators");
        this.WriteNodeGenerators(isGreen: false);
        this.WriteLine("#endregion Red Generators");
        this.WriteLine();

        this.WriteLine("#region Red Factory and Property Tests");
        this.WriteFactoryPropertyTests(isGreen: false);
        this.WriteLine("#endregion Red Factory and Property Tests");
        this.WriteLine();

        this.WriteLine("#region Red Rewriters");
        this.WriteRewriterTests();
        this.WriteLine("#endregion Red Rewriters");

        this.CloseBlock();

        this.CloseBlock();
    }

    private void WriteNodeGenerators(bool isGreen)
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode);
        bool first = true;
        foreach (var node in nodes)
        {
            if (!first)
            {
                this.WriteLine();
            }
            first = false;
            this.WriteNodeGenerator((Node)node, isGreen);
        }
    }

    private void WriteNodeGenerator(Node node, bool isGreen)
    {
        var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
        var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

        var internalNamespace = isGreen ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." : "";
        var csharpNamespace = isGreen ? "Syntax.InternalSyntax." : "";
        var syntaxFactory = isGreen ? "InternalSyntaxFactory" : "SyntaxFactory";

        var strippedName = StripPost(node.Name, "Syntax");

        this.WriteLine($"private static {csharpNamespace}{node.Name} Generate{strippedName}()");

        this.Write($"    => {syntaxFactory}.{strippedName}(");
        //instantiate node

        bool first = true;

        if (node.Kinds.Count > 1)
        {
            this.Write($"SyntaxKind.{node.Kinds[0].Name}"); //TODO: other kinds?
            first = false;
        }

        foreach (var field in nodeFields)
        {
            if (!first)
            {
                this.Write(", ");
            }
            first = false;

            if (field.IsOptional())
            {
                if (isGreen)
                {
                    this.Write("null");
                }
                else
                {
                    this.Write($"default({field.Type})");
                }
            }
            else if (field.Type.IsAnyList())
            {
                string typeName;
                if (isGreen)
                {
                    typeName = internalNamespace + field.Type.Replace("<", "<" + csharpNamespace);
                }
                else
                {
                    typeName = (field.Type == "SyntaxList<SyntaxToken>") ? "SyntaxTokenList" : field.Type;
                }
                this.Write($"new {typeName}()");
            }
            else if (field.Type == "SyntaxToken")
            {
                var kind = ChooseValidKind(field, node);
                var leadingTrivia = isGreen ? "null, " : string.Empty;
                var trailingTrivia = isGreen ? ", null" : string.Empty;
                if (kind == "IdentifierToken")
                {
                    this.Write($"{syntaxFactory}.Identifier(\"{field.Name}\")");
                }
                else if (kind == "StringLiteralToken")
                {
                    this.Write($"{syntaxFactory}.Literal({leadingTrivia}\"string\", \"string\"{trailingTrivia})");
                }
                else if (kind == "CharacterLiteralToken")
                {
                    this.Write($"{syntaxFactory}.Literal({leadingTrivia}\"a\", 'a'{trailingTrivia})");
                }
                else if (kind == "NumericLiteralToken")
                {
                    this.Write($"{syntaxFactory}.Literal({leadingTrivia}\"1\", 1{trailingTrivia})");
                }
                else
                {
                    this.Write($"{syntaxFactory}.Token(SyntaxKind.{kind})");
                }
            }
            else if (field.Type == "CSharpSyntaxNode")
            {
                this.Write($"{syntaxFactory}.IdentifierName({syntaxFactory}.Identifier(\"{field.Name}\"))");
            }
            else
            {
                //drill down to a concrete type
                var type = field.Type;
                while (true)
                {
                    var subTypes = ChildMap[type];
                    if (!subTypes.Any())
                    {
                        break;
                    }
                    type = subTypes.First();
                }
                this.Write($"Generate{StripPost(type, "Syntax")}()");
            }
        }

        foreach (var field in valueFields)
        {
            if (!first)
            {
                this.Write(", ");
            }
            first = false;

            this.Write($"new {field.Type}()");
        }

        this.WriteLine(");");
    }

    private void WriteFactoryPropertyTests(bool isGreen)
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode);
        bool first = true;
        foreach (var node in nodes)
        {
            if (!first)
            {
                this.WriteLine();
            }
            first = false;
            this.WriteFactoryPropertyTest((Node)node, isGreen);
        }
    }

    private void WriteFactoryPropertyTest(Node node, bool isGreen)
    {
        var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
        var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

        var strippedName = StripPost(node.Name, "Syntax");

        this.WriteLine("[Fact]");
        this.WriteLine($"public void Test{strippedName}FactoryAndProperties()");
        this.OpenBlock();

        this.WriteLine($"var node = Generate{strippedName}();");

        this.WriteLine();

        //check properties
        {
            string? withStat = null;
            foreach (var field in nodeFields)
            {
                if (field.IsOptional())
                {
                    if (!isGreen && field.Type == "SyntaxToken")
                    {
                        this.WriteLine($"Assert.Equal(SyntaxKind.None, node.{field.Name}.Kind());");
                    }
                    else
                    {
                        this.WriteLine($"Assert.Null(node.{field.Name});");
                    }
                }
                else if (field.Type == "SyntaxToken")
                {
                    var kind = ChooseValidKind(field, node);
                    if (!isGreen)
                    {
                        this.WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind());");
                    }
                    else
                    {
                        this.WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind);");
                    }
                }
                else
                {
                    if (field.Type == "SyntaxToken")
                    {
                        this.WriteLine($"Assert.NotEqual(default, node.{field.Name});");
                    }
                    else if (
                        field.Type == "SyntaxTokenList" ||
                        field.Type.StartsWith("SyntaxList<") ||
                        field.Type.StartsWith("SeparatedSyntaxList<"))
                    {
                        this.WriteLine($"Assert.Equal(default, node.{field.Name});");
                    }
                    else
                    {
                        this.WriteLine($"Assert.NotNull(node.{field.Name});");
                    }
                }

                if (!isGreen)
                {
                    withStat += $".With{field.Name}(node.{field.Name})";
                }
            }

            foreach (var field in valueFields)
            {
                this.WriteLine($"Assert.Equal(new {field.Type}(), node.{field.Name});");
                if (!isGreen)
                {
                    withStat += $".With{field.Name}(node.{field.Name})";
                }
            }

            if (!isGreen && withStat != null)
            {
                this.WriteLine($"var newNode = node{withStat};");
                this.WriteLine("Assert.Equal(node, newNode);");
            }
        }

        if (isGreen)
        {
            this.WriteLine();
            this.WriteLine("AttachAndCheckDiagnostics(node);");
        }

        this.CloseBlock();
    }

    private void WriteRewriterTests()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode);
        bool first = true;
        foreach (var node in nodes)
        {
            if (!first)
            {
                this.WriteLine();
            }
            first = false;
            this.WriteTokenDeleteRewriterTest((Node)node);
            this.WriteLine();
            this.WriteIdentityRewriterTest((Node)node);
        }
    }

    private void WriteTokenDeleteRewriterTest(Node node)
    {
        var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
        var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

        var strippedName = StripPost(node.Name, "Syntax");

        this.WriteLine("[Fact]");
        this.WriteLine($"public void Test{strippedName}TokenDeleteRewriter()");
        this.OpenBlock();

        this.WriteLine($"var oldNode = Generate{strippedName}();");
        this.WriteLine("var rewriter = new TokenDeleteRewriter();");
        this.WriteLine("var newNode = rewriter.Visit(oldNode);");

        this.WriteLine();
        this.WriteLine("if(!oldNode.IsMissing)");
        this.OpenBlock();
        this.WriteLine("Assert.NotEqual(oldNode, newNode);");
        this.CloseBlock();

        this.WriteLine();
        this.WriteLine("Assert.NotNull(newNode);");
        this.WriteLine("Assert.True(newNode.IsMissing, \"No tokens => missing\");");

        this.CloseBlock();
    }

    private void WriteIdentityRewriterTest(Node node)
    {
        var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
        var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

        var strippedName = StripPost(node.Name, "Syntax");

        this.WriteLine("[Fact]");
        this.WriteLine($"public void Test{strippedName}IdentityRewriter()");
        this.OpenBlock();

        this.WriteLine($"var oldNode = Generate{strippedName}();");
        this.WriteLine("var rewriter = new IdentityRewriter();");
        this.WriteLine("var newNode = rewriter.Visit(oldNode);");

        this.WriteLine();

        this.WriteLine("Assert.Same(oldNode, newNode);");

        this.CloseBlock();
    }

    //guess a reasonable kind if there are no constraints
    private string ChooseValidKind(Field field, Node nd)
    {
        var fieldKinds = GetKindsOfFieldOrNearestParent(nd, field);
        return fieldKinds?.Any() == true ? fieldKinds[0].Name : "IdentifierToken";
    }
}
