// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Xml;
using Microsoft.CodeAnalysis;

namespace Luna.Tools.Syntax;

using Model;

internal class SyntaxSourceWriter : SyntaxFileWriter
{
    private SyntaxSourceWriter(TextWriter writer, SyntaxSourceProductionContext context)
        : base(writer, context) { }

    /// <summary>
    /// 写入红树节点的访问、重写和工厂方法。
    /// </summary>
    public static void WriteMain(TextWriter writer, SyntaxSourceProductionContext context) => new SyntaxSourceWriter(writer, context).WriteMain();

    /// <summary>
    /// 写入绿树节点的类型定义及访问、重写和上下文、静态工厂方法。
    /// </summary>
    public static void WriteInternal(TextWriter writer, SyntaxSourceProductionContext context) => new SyntaxSourceWriter(writer, context).WriteInternal();

    /// <summary>
    /// 写入红树节点的类型定义。
    /// </summary>
    public static void WriteSyntax(TextWriter writer, SyntaxSourceProductionContext context) => new SyntaxSourceWriter(writer, context).WriteSyntax();

    private void WriteFileHeader()
    {
        WriteLine("// <auto-generated />");
        WriteLine();
        WriteLine("#nullable enable");
        WriteLine();
        WriteLine("using System;");
        WriteLine("using System.Collections.Generic;");
        WriteLine("using System.Diagnostics.CodeAnalysis;");
        WriteLine("using Microsoft.CodeAnalysis;");
        WriteLine("using Microsoft.CodeAnalysis.Syntax.InternalSyntax;");
        WriteLine($"using Qtyi.CodeAnalysis.{ThisLanguageName};");
        WriteLine("using Roslyn.Utilities;");
        WriteLine();
    }

    private void WriteMain()
    {
        WriteFileHeader();
        WriteLine($"namespace Qtyi.CodeAnalysis.{ThisLanguageName};");
        WriteLine();
        WriteLine("using System.Diagnostics.CodeAnalysis;");
        WriteLine("using Microsoft.CodeAnalysis;");
        WriteLine($"using Qtyi.CodeAnalysis.{ThisLanguageName}.Syntax;");
        WriteRedVisitors();
        WriteRedRewriter();
        WriteRedFactories();
    }

    private void WriteInternal()
    {
        WriteFileHeader();
        WriteLine($"namespace Qtyi.CodeAnalysis.{ThisLanguageName}.Syntax.InternalSyntax;");
        WriteGreenTypes();
        WriteGreenVisitors();
        WriteGreenAccumulator();
        WriteGreenTraverser();
        WriteGreenRewriter();
        WriteContextualGreenFactories();
        WriteStaticGreenFactories();
        WriteGreenInfo();
    }

    private void WriteSyntax()
    {
        WriteFileHeader();
        WriteLine($"namespace Qtyi.CodeAnalysis.{ThisLanguageName}.Syntax;");
        WriteLine();
        WriteLine("using Microsoft.CodeAnalysis;");
        WriteRedTypes();
    }

    private void WriteGreenTypes()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();
        foreach (var node in nodes)
        {
            WriteLine();
            WriteGreenType(node);
        }
    }

    private void WriteGreenType(SyntaxTreeType node)
    {
        WriteComment(node.TypeComment, "");

        if (node is AbstractNode)
        {
            var nd = (AbstractNode)node;
            WriteLine($"internal abstract partial class {node.Name} : {node.Base}");
            this.OpenBlock();

            // ctor with diagnostics and annotations
            WriteLine($"internal {node.Name}(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)");
            WriteLine("  : base(kind, diagnostics, annotations)");
            this.OpenBlock();
            if (node.Name == "DirectiveTriviaSyntax")
            {
                WriteLine("SetFlags(NodeFlags.ContainsDirectives);");
            }
            this.CloseBlock();
            WriteLine();
            // ctor without diagnostics and annotations
            WriteLine($"internal {node.Name}(SyntaxKind kind)");
            WriteLine("  : base(kind)");
            this.OpenBlock();
            if (node.Name == "DirectiveTriviaSyntax")
            {
                WriteLine("SetFlags(NodeFlags.ContainsDirectives);");
            }
            this.CloseBlock();

            var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

            foreach (var field in nodeFields)
            {
                WriteLine();
                WriteComment(field.PropertyComment, "");

                if (field.IsSeparatedNodeList ||
                    field.IsNodeList)
                {
                    WriteLine($"public abstract {(field.IsNew() ? "new " : "")}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type} {field.Name} {{ get; }}");
                }
                else
                {
                    WriteLine($"public abstract {(field.IsNew() ? "new " : "")}{(GetFieldType(field, green: true))} {field.Name} {{ get; }}");
                }
            }

            foreach (var field in valueFields)
            {
                WriteLine();
                WriteComment(field.PropertyComment, "");

                WriteLine($"public abstract {(field.IsNew() ? "new " : "")}{field.Type} {field.Name} {{ get; }}");
            }

            this.CloseBlock();
        }
        else if (node is Node)
        {
            var nd = (Node)node;

            WriteLine($"internal sealed partial class {node.Name} : {node.Base}");
            this.OpenBlock();

            var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

            foreach (var field in nodeFields)
            {
                var type = GetFieldType(field, green: true);
                WriteLine($"internal readonly {type} {CamelCase(field.Name)};");
            }

            foreach (var field in valueFields)
            {
                WriteLine($"internal readonly {field.Type} {CamelCase(field.Name)};");
            }

            // write constructor with diagnostics and annotations
            WriteLine();
            Write($"internal {node.Name}(SyntaxKind kind");

            WriteGreenNodeConstructorArgs(nodeFields, valueFields);

            WriteLine(", DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)");
            WriteLine("  : base(kind, diagnostics, annotations)");
            this.OpenBlock();
            WriteCtorBody(valueFields, nodeFields);
            this.CloseBlock();

            // write constructor with async
            WriteLine();
            Write($"internal {node.Name}(SyntaxKind kind");

            WriteGreenNodeConstructorArgs(nodeFields, valueFields);

            WriteLine(", SyntaxFactoryContext context)");
            WriteLine("  : base(kind)");
            this.OpenBlock();
            WriteLine("this.SetFactoryContext(context);");
            WriteCtorBody(valueFields, nodeFields);
            this.CloseBlock();

            // write constructor without diagnostics and annotations
            WriteLine();
            Write($"internal {node.Name}(SyntaxKind kind");

            WriteGreenNodeConstructorArgs(nodeFields, valueFields);

            WriteLine(")");
            WriteLine("  : base(kind)");
            this.OpenBlock();
            WriteCtorBody(valueFields, nodeFields);
            this.CloseBlock();
            WriteLine();

            // property accessors
            foreach (var field in nodeFields)
            {
                var directlyOverride = string.Compare(field.Override, "true", true) == 0;
                var overriddenName = field.IsOverride()
                    ? directlyOverride ? field.Name : field.Override
                    : field.Name;
                WriteComment(field.PropertyComment, "");
                if (field.IsNodeList)
                {
                    WriteLine($"public {OverrideOrNewModifier(field)}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type} {overriddenName} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type}(this.{CamelCase(field.Name)});");
                    if (field.IsOverride() && !directlyOverride)
                        WriteLine($"public Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type} {field.Name} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type}(this.{CamelCase(field.Name)});");
                }
                else if (field.IsSeparatedNodeList)
                {
                    WriteLine($"public {OverrideOrNewModifier(field)}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type} {overriddenName} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type}(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>(this.{CamelCase(field.Name)}));");
                    if (field.IsOverride() && !directlyOverride)
                        WriteLine($"public Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type} {field.Name} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{field.Type}(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>(this.{CamelCase(field.Name)}));");
                }
                else if (field.Type == "SyntaxNodeOrTokenList")
                {
                    WriteLine($"public {OverrideOrNewModifier(field)}Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode> {overriddenName} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>(this.{CamelCase(field.Name)});");
                    if (field.IsOverride() && !directlyOverride)
                        WriteLine($"public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode> {field.Name} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>(this.{CamelCase(field.Name)});");
                }
                else
                {
                    WriteLine($"public {OverrideOrNewModifier(field)}{(GetFieldType(field, green: true))} {overriddenName} => this.{CamelCase(field.Name)};");
                    if (field.IsOverride() && !directlyOverride)
                        WriteLine($"public {(GetFieldType(field, green: true))} {field.Name} => this.{CamelCase(field.Name)};");
                }
            }

            foreach (var field in valueFields)
            {
                bool directlyOverride = string.Compare(field.Override, "true", true) == 0;
                var overriddenName = field.IsOverride()
                    ? directlyOverride ? field.Name : field.Override
                    : field.Name;
                WriteComment(field.PropertyComment, "");
                WriteLine($"public {OverrideOrNewModifier(field)}{field.Type} {overriddenName} => this.{CamelCase(field.Name)};");
                if (field.IsOverride() && !directlyOverride)
                    WriteLine($"public {field.Type} {field.Name} => this.{CamelCase(field.Name)};");
            }

            // GetSlot
            WriteLine();
            Write("internal override GreenNode? GetSlot(int index)");

            if (nodeFields.Count == 0)
            {
                WriteLine(" => null;");
            }
            else if (nodeFields.Count == 1)
            {
                WriteLine();
                Indent();
                WriteLine($"=> index == 0 ? this.{CamelCase(nodeFields[0].Name)} : null;");
                Unindent();
            }
            else
            {
                WriteLine();
                Indent();
                WriteLine("=> index switch");
                this.OpenBlock();
                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];
                    WriteLine($"{i} => this.{CamelCase(field.Name)},");
                }
                WriteLine("_ => null,");
                this.CloseBlock(";");
                Unindent();
            }

            WriteLine();
            WriteLine($"internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new {ThisLanguageName}.Syntax.{node.Name}(this, parent as {ThisLanguageName}.{ThisLanguageName}SyntaxNode, position);");

            WriteGreenAcceptMethods(nd);
            WriteGreenUpdateMethod(nd);
            WriteSetDiagnostics(nd);
            WriteSetAnnotations(nd);

            WriteGreenSerialization(nd);
            this.CloseBlock();
        }
    }

    private void WriteGreenNodeConstructorArgs(List<Field> nodeFields, List<Field> valueFields)
    {
        foreach (var field in nodeFields)
        {
            Write($", {(GetFieldType(field, green: true))} {CamelCase(field.Name)}");
        }

        foreach (var field in valueFields)
        {
            Write($", {field.Type} {CamelCase(field.Name)}");
        }
    }

    private void WriteGreenSerialization(Node node)
    {
        var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
        var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();
    }

    private void WriteCtorBody(List<Field> valueFields, List<Field> nodeFields)
    {
        // constructor body
        WriteLine($"this.SlotCount = {nodeFields.Count};");

        foreach (var field in nodeFields)
        {
            if (field.Type.IsAnyList() || field.IsOptional())
            {
                WriteLine($"if ({CamelCase(field.Name)} is not null)");
                this.OpenBlock();
                WriteLine($"this.AdjustFlagsAndWidth({CamelCase(field.Name)});");
                WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
                this.CloseBlock();
            }
            else
            {
                WriteLine($"this.AdjustFlagsAndWidth({CamelCase(field.Name)});");
                WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
            }
        }

        foreach (var field in valueFields)
        {
            WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
        }
    }

    private void WriteSetAnnotations(Node node)
    {
        WriteLine();
        WriteLine("internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)");
        Write($"    => new {node.Name}(");
        Write(CommaJoin(
            "this.Kind",
            node.Fields.Select(f => $"this.{CamelCase(f.Name)}"),
            "GetDiagnostics()",
            "annotations"));
        WriteLine(");");
    }

    private void WriteSetDiagnostics(Node node)
    {
        WriteLine();
        WriteLine("internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)");
        Write($"    => new {node.Name}(");
        Write(CommaJoin(
            "this.Kind",
            node.Fields.Select(f => $"this.{CamelCase(f.Name)}"),
            "diagnostics",
            "GetAnnotations()"));
        WriteLine(");");
    }

    private void WriteGreenAcceptMethods(Node node)
    {
        WriteLine();
        WriteLine($"public override void Accept({ThisLanguageName}SyntaxVisitor visitor) => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
        WriteLine($"public override TResult? Accept<TResult>({ThisLanguageName}SyntaxVisitor<TResult> visitor) where TResult : default => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
    }

    private void WriteGreenVisitors()
    {
        WriteGreenVisitor(withResult: true);
        WriteGreenVisitor(withResult: false);
    }

    private void WriteGreenVisitor(bool withResult)
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxVisitor" + (withResult ? "<TResult>" : ""));
        this.OpenBlock();
        foreach (var node in nodes.OfType<Node>())
        {
            WriteLine($"public virtual {(withResult ? "TResult?" : "void")} Visit{StripPost(node.Name, "Syntax")}({node.Name} node) => this.DefaultVisit(node);");
        }
        this.CloseBlock();
    }

    private void WriteGreenUpdateMethod(Node node)
    {
        WriteLine();
        Write($"public {node.Name} Update(");
        Write(CommaJoin(node.Fields.Select(f =>
        {
            var type =
                f.Type == "SyntaxNodeOrTokenList" ? $"Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>" :
                f.Type == "SyntaxTokenList" ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>" :
                f.IsNodeList ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." + f.Type :
                f.IsSeparatedNodeList ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." + f.Type :
                f.Type + (f.IsOptional() ? "?" : string.Empty);

            return $"{type} {CamelCase(f.Name)}";
        })));
        WriteLine(")");
        this.OpenBlock();

        Write("if (");
        int nCompared = 0;
        foreach (var field in node.Fields)
        {
            if (IsDerivedOrListOfDerived("SyntaxNode", field.Type) || IsDerivedOrListOfDerived("SyntaxToken", field.Type) || field.Type == "SyntaxNodeOrTokenList")
            {
                if (nCompared > 0)
                    Write(" || ");
                Write($"{CamelCase(field.Name)} != this.{field.Name}");
                nCompared++;
            }
        }
        if (nCompared > 0)
        {
            WriteLine(")");
            this.OpenBlock();
            Write($"var newNode = SyntaxFactory.{StripPost(node.Name, "Syntax")}(");
            Write(CommaJoin(
                node.Kinds.Count > 1 ? "this.Kind" : "",
                node.Fields.Select(f => CamelCase(f.Name))));
            WriteLine(");");
            WriteLine("var diags = GetDiagnostics();");
            WriteLine("if (diags?.Length > 0)");
            WriteLine("    newNode = newNode.WithDiagnosticsGreen(diags);");
            WriteLine("var annotations = GetAnnotations();");
            WriteLine("if (annotations?.Length > 0)");
            WriteLine("    newNode = newNode.WithAnnotationsGreen(annotations);");
            WriteLine("return newNode;");
            this.CloseBlock();
        }

        WriteLine();
        WriteLine("return this;");
        this.CloseBlock();
    }

    private void WriteGreenAccumulator()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxAccumulator<TResult> : {ThisLanguageName}SyntaxVisitor<IEnumerable<TResult>>");
        this.OpenBlock();
        int nWritten = 0;
        foreach (var node in nodes.OfType<Node>())
        {
            var nodeFields = node.Fields.Where(nd => IsNodeOrNodeList(nd.Type)).ToList();

            if (nWritten > 0)
                WriteLine();
            nWritten++;
            WriteLine($"public override IEnumerable<TResult> Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");
            this.OpenBlock();

            if (nodeFields.Count == 0)
            {
                WriteLine("yield break;");
            }
            else
            {
                foreach (var f in node.Fields)
                {
                    string visitMethod;
                    if (f.Type.IsAnyList())
                        visitMethod = "VisitList";
                    else if (f.Type == "SyntaxToken")
                        visitMethod = "Visit";
                    else if (IsNode(f.Type))
                        visitMethod = "Visit";
                    else
                        continue;
                    if (!f.Type.IsAnyList() && f.IsOptional())
                        Write($"if (node.{f.Name} is not null) ");
                    WriteLine($"foreach (var result in this.{visitMethod}(node.{f.Name})) yield return result;");
                }
            }

            this.CloseBlock();
        }

        this.CloseBlock();
    }

    private void WriteGreenTraverser()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxTraverser : {ThisLanguageName}SyntaxVisitor");
        this.OpenBlock();
        int nWritten = 0;
        foreach (var node in nodes.OfType<Node>())
        {
            var nodeFields = node.Fields.Where(nd => IsNodeOrNodeList(nd.Type)).ToList();

            if (nWritten > 0)
                WriteLine();
            nWritten++;
            WriteLine($"public override void Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");
            this.OpenBlock();

            if (nodeFields.Count != 0)
            {
                foreach (var f in node.Fields)
                {
                    string visitMethod;
                    if (f.Type.IsAnyList())
                        visitMethod = "VisitList";
                    else if (f.Type == "SyntaxToken")
                        visitMethod = "Visit";
                    else if (IsNode(f.Type))
                        visitMethod = "Visit";
                    else
                        continue;
                    if (!f.Type.IsAnyList() && f.IsOptional())
                        Write($"if (node.{f.Name} is not null) ");
                    WriteLine($"this.{visitMethod}(node.{f.Name});");
                }
            }

            this.CloseBlock();
        }

        this.CloseBlock();
    }

    private void WriteGreenRewriter()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxRewriter : {ThisLanguageName}SyntaxVisitor<{ThisLanguageName}SyntaxNode>");
        this.OpenBlock();
        int nWritten = 0;
        foreach (var node in nodes.OfType<Node>())
        {
            var nodeFields = node.Fields.Where(nd => IsNodeOrNodeList(nd.Type)).ToList();

            if (nWritten > 0)
                WriteLine();
            nWritten++;
            WriteLine($"public override {ThisLanguageName}SyntaxNode Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");
            Indent();

            if (nodeFields.Count == 0)
            {
                WriteLine("=> node;");
            }
            else
            {
                Write("=> node.Update(");
                Write(CommaJoin(node.Fields.Select(f =>
                {
                    if (f.Type.IsAnyList())
                        return $"this.VisitList(node.{f.Name})";
                    else if (IsNode(f.Type))
                        return $"({f.Type}{(f.IsOptional() ? "?" : string.Empty)})this.Visit(node.{f.Name}){(!f.IsOptional() ? "!" : string.Empty)}";
                    else
                        return $"node.{f.Name}";
                })));
                WriteLine(");");
            }

            Unindent();
        }

        this.CloseBlock();
    }

    private void WriteContextualGreenFactories()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).ToList();
        WriteLine();
        WriteLine("partial class ContextAwareSyntax");
        this.OpenBlock();
        WriteLine();
        WriteLine("private SyntaxFactoryContext context;");

        WriteLine();
        WriteLine("public ContextAwareSyntax(SyntaxFactoryContext context)");
        WriteLine("    => this.context = context;");

        WriteGreenFactories(nodes, withSyntaxFactoryContext: true);
        this.CloseBlock();
    }

    private void WriteStaticGreenFactories()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).ToList();
        WriteLine();
        WriteLine("static partial class SyntaxFactory");
        this.OpenBlock();
        WriteGreenFactories(nodes);
        WriteGreenTypeList();
        this.CloseBlock();
    }

    private void WriteGreenInfo()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode)
                              .GroupBy(n => ((Node)n).Fields.Count)
                              .OrderByDescending(g => g.Key)
                              .First();
        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxNode");
        this.OpenBlock();
        WriteLine("#if DEBUG");
        Write("/// <summary>Max slot count. (");
        Write(Join(", ", true, nodes.Select(n => (object)n.Name).ToArray()));
        WriteLine(")</summary>");
        WriteLine($"private const int MaxSlotCount = {nodes.Key};");
        WriteLine("#endif");
        this.CloseBlock();
    }

    private void WriteGreenFactories(List<SyntaxTreeType> nodes, bool withSyntaxFactoryContext = false)
    {
        foreach (var node in nodes.OfType<Node>())
        {
            WriteLine();
            WriteGreenFactory(node, withSyntaxFactoryContext);
        }
    }

    private void WriteGreenTypeList()
    {
        WriteLine();
        WriteLine("internal static IEnumerable<Type> GetNodeTypes()");
        Indent();
        WriteLine("=> new Type[]");
        this.OpenBlock();

        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).ToList();
        foreach (var node in nodes)
        {
            WriteLine($"typeof({node.Name}),");
        }

        this.CloseBlock(";");
        Unindent();
    }

    private void WriteGreenFactory(Node nd, bool withSyntaxFactoryContext = false)
    {
        var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
        var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

        Write($"public {(withSyntaxFactoryContext ? "" : "static ")}{nd.Name} {StripPost(nd.Name, "Syntax")}(");
        WriteGreenFactoryParameters(nd);
        WriteLine(")");
        this.OpenBlock();

        // validate kind
        if (nd.Kinds.Count >= 2)
        {
            WriteLine("switch (kind)");
            this.OpenBlock();
            var kinds = nd.Kinds.Distinct().ToList();
            foreach (var kind in kinds)
            {
                WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");
            }
            WriteLine("default: throw new ArgumentException(nameof(kind));");
            this.CloseBlock();
        }

        // validate parameters
        WriteLineWithoutIndent("#if DEBUG");
        foreach (var field in nodeFields)
        {
            var pname = CamelCase(field.Name);

            if (!field.Type.IsAnyList() && !field.IsOptional())
            {
                WriteLine($"if ({CamelCase(field.Name)} is null) throw new ArgumentNullException(nameof({CamelCase(field.Name)}));");
            }
            if (field.Type == "SyntaxToken" && field.Kinds is not null && field.Kinds.Count > 0)
            {
                if (field.IsOptional())
                {
                    WriteLine($"if ({CamelCase(field.Name)} is not null)");
                    this.OpenBlock();
                }

                if (field.Kinds.Count == 1 && !field.IsOptional())
                {
                    WriteLine($"if ({pname}.Kind != SyntaxKind.{field.Kinds[0].Name}) throw new ArgumentException(nameof({pname}));");
                }
                else
                {
                    WriteLine($"switch ({pname}.Kind)");
                    this.OpenBlock();
                    var kinds = field.Kinds.Distinct().ToList();

                    //we need to check for Kind=None as well as node is null because that's what the red factory will pass
                    if (field.IsOptional())
                    {
                        kinds.Add(new Kind { Name = "None" });
                    }
                    foreach (var kind in kinds)
                    {
                        WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");
                    }

                    WriteLine($"default: throw new ArgumentException(nameof({pname}));");
                    this.CloseBlock();
                }

                if (field.IsOptional())
                {
                    this.CloseBlock();
                }
            }
        }

        WriteLineWithoutIndent("#endif");

        if (nd.Name != "SkippedTokensTriviaSyntax" &&
            nd.Name != "BadDirectiveTriviaSyntax" &&
            nd.Name != "ShebangDirectiveTriviaSyntax" &&
            nd.Name != "CommentDirectiveTriviaSyntax" &&
            nd.Name != "DocumentationCommentTriviaSyntax" &&
            valueFields.Count + nodeFields.Count <= 3)
        {
            //int hash;
            //var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
            //if (cached is not null) return (IdentifierNameSyntax)cached;

            //var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
            //if (hash >= 0)
            //{
            //    SyntaxNodeCache.AddNode(result, hash);
            //}

            //return result;

            WriteLine();
            //int hash;
            WriteLine("int hash;");
            //SyntaxNode cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierName, identifier, this.context, out hash);
            if (withSyntaxFactoryContext)
            {
                Write($"var cached = {ThisLanguageName}SyntaxNodeCache.TryGetNode((int)");
            }
            else
            {
                Write("var cached = SyntaxNodeCache.TryGetNode((int)");
            }

            WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
            WriteLine(", out hash);");
            //    if (cached is not null) return (IdentifierNameSyntax)cached;
            WriteLine($"if (cached is not null) return ({nd.Name})cached;");
            WriteLine();

            //var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
            Write($"var result = new {nd.Name}(");
            WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
            WriteLine(");");
            //if (hash >= 0)
            WriteLine("if (hash >= 0)");
            //{
            this.OpenBlock();
            //    SyntaxNodeCache.AddNode(result, hash);
            WriteLine("SyntaxNodeCache.AddNode(result, hash);");
            //}
            this.CloseBlock();
            WriteLine();

            //return result;
            WriteLine("return result;");
        }
        else
        {
            WriteLine();
            Write($"return new {nd.Name}(");
            WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
            WriteLine(");");
        }

        this.CloseBlock();
    }

    private void WriteGreenFactoryParameters(Node nd)
    {
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "SyntaxKind kind" : "",
            nd.Fields.Select(f =>
            {
                var type = f.Type switch
                {
                    "SyntaxNodeOrTokenList" => $"Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<{ThisLanguageName}SyntaxNode>",
                    _ when f.IsSeparatedNodeList || f.IsNodeList => $"Microsoft.CodeAnalysis.Syntax.InternalSyntax.{f.Type}",
                    _ => GetFieldType(f, green: true),
                };

                return $"{type} {CamelCase(f.Name)}";
            })));
    }

    private void WriteCtorArgList(Node nd, bool withSyntaxFactoryContext, List<Field> valueFields, List<Field> nodeFields)
    {
        Write(CommaJoin(
            nd.Kinds.Count == 1 ? $"SyntaxKind.{nd.Kinds[0].Name}" : "kind",
            nodeFields.Select(f =>
                f.Type == "SyntaxList<SyntaxToken>" || f.Type.IsAnyList()
                    ? $"{CamelCase(f.Name)}.Node"
                    : CamelCase(f.Name)),
            // values are at end
            valueFields.Select(f => CamelCase(f.Name)),
            withSyntaxFactoryContext ? "this.context" : ""));
    }

    private void WriteRedTypes()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();
        foreach (var node in nodes)
        {
            WriteLine();
            WriteRedType(node);
        }
    }

    private List<Field> GetNodeOrNodeListFields(SyntaxTreeType node)
        => node is AbstractNode an
            ? an.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList()
            : node is Node nd
                ? nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList()
                : new List<Field>();

    private void WriteRedType(SyntaxTreeType node)
    {
        WriteComment(node.TypeComment, "");

        if (node is AbstractNode)
        {
            var nd = (AbstractNode)node;
            WriteLine($"public abstract partial class {node.Name} : {node.Base}");
            this.OpenBlock();
            WriteLine($"internal {node.Name}(InternalSyntax.{ThisLanguageName}SyntaxNode green, {ThisLanguageName}SyntaxNode? parent, int position)");
            WriteLine("  : base(green, parent, position)");
            this.OpenBlock();
            this.CloseBlock();

            var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = GetNodeOrNodeListFields(nd);

            foreach (var field in nodeFields)
            {
                if (IsNodeOrNodeList(field.Type))
                {
                    //red SyntaxLists can't contain tokens, so we switch to SyntaxTokenList
                    var fieldType = GetRedFieldType(field);
                    WriteLine();
                    WriteComment(field.PropertyComment, "");
                    WriteLine($"{"public"} abstract {(field.IsNew() ? "new " : "")}{fieldType} {field.Name} {{ get; }}");
                    WriteLine($"public {node.Name} With{field.Name}({fieldType} {CamelCase(field.Name)}) => With{field.Name}Core({CamelCase(field.Name)});");
                    WriteLine($"internal abstract {node.Name} With{field.Name}Core({fieldType} {CamelCase(field.Name)});");

                    if (field.Type.IsAnyList())
                    {
                        var argType = GetElementType(field.Type);
                        WriteLine();
                        WriteLine($"public {node.Name} Add{field.Name}(params {argType}[] items) => Add{field.Name}Core(items);");
                        WriteLine($"internal abstract {node.Name} Add{field.Name}Core(params {argType}[] items);");
                    }
                    else
                    {
                        var referencedNode = TryGetNodeForNestedList(field);
                        if (referencedNode is not null)
                        {
                            foreach (var referencedNodeField in referencedNode.Fields)
                            {
                                if (referencedNodeField.Type.IsAnyList())
                                {
                                    var argType = GetElementType(referencedNodeField.Type);

                                    WriteLine();
                                    WriteLine($"public {node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items) => Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}Core(items);");
                                    WriteLine($"internal abstract {node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}Core(params {argType}[] items);");
                                }
                            }
                        }
                    }
                }
            }

            foreach (var field in valueFields)
            {
                WriteLine();
                WriteComment(field.PropertyComment, "");
                WriteLine($"{"public"} abstract {(field.IsNew() ? "new " : "")}{field.Type} {field.Name} {{ get; }}");
            }

            var baseType = GetTreeType(node.Base);
            if (baseType is not null)
            {
                var baseNodeFields = GetNodeOrNodeListFields(baseType);
                if (baseNodeFields.Count > 0)
                {
                    WriteLine();
                }

                foreach (var baseField in baseNodeFields)
                {
                    WriteLine($"public new {node.Name} With{baseField.Name}({GetRedFieldType(baseField)} {CamelCase(baseField.Name)}) => ({node.Name})With{baseField.Name}Core({CamelCase(baseField.Name)});");
                }

                foreach (var baseField in baseNodeFields)
                {
                    if (baseField.Type.IsAnyList())
                    {
                        var argType = GetElementType(baseField.Type);
                        WriteLine();
                        WriteLine($"public new {node.Name} Add{baseField.Name}(params {argType}[] items) => ({node.Name})Add{baseField.Name}Core(items);");
                    }
                    else
                    {
                        var referencedNode = TryGetNodeForNestedList(baseField);
                        if (referencedNode is not null)
                        {
                            // look for list members...
                            foreach (var referencedNodeField in referencedNode.Fields)
                            {
                                if (referencedNodeField.Type.IsAnyList())
                                {
                                    var argType = GetElementType(referencedNodeField.Type);

                                    WriteLine();
                                    WriteLine($"public new {baseType.Name} Add{StripPost(baseField.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items) => Add{StripPost(baseField.Name, "Opt")}{referencedNodeField.Name}Core(items);");
                                }
                            }
                        }
                    }
                }
            }

            this.CloseBlock();
        }
        else if (node is Node)
        {
            var nd = (Node)node;
            WriteComment($"<remarks>");
            WriteComment($"<para>This node is associated with the following syntax kinds:</para>");
            WriteComment($"<list type=\"bullet\">");

            foreach (var kind in nd.Kinds)
            {
                WriteComment($"<item><description><see cref=\"SyntaxKind.{kind.Name}\"/></description></item>");
            }

            WriteComment($"</list>");
            WriteComment($"</remarks>");
            WriteLine($"public sealed partial class {node.Name} : {node.Base}");
            this.OpenBlock();

            var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

            foreach (var field in nodeFields)
            {
                if (field.Type is not "SyntaxToken"
                    and not "SyntaxList<SyntaxToken>")
                {
                    if (field.IsSeparatedNodeList || field.Type == "SyntaxNodeOrTokenList")
                    {
                        WriteLine($"private SyntaxNode? {CamelCase(field.Name)};");
                    }
                    else
                    {
                        var type = GetFieldType(field, green: false);
                        WriteLine($"private {type} {CamelCase(field.Name)};");
                    }
                }
            }

            // write constructor
            WriteLine();
            WriteLine($"internal {node.Name}(InternalSyntax.{ThisLanguageName}SyntaxNode green, {ThisLanguageName}SyntaxNode? parent, int position)");
            WriteLine("  : base(green, parent, position)");
            this.OpenBlock();
            this.CloseBlock();
            WriteLine();

            // property accessors
            for (int i = 0, n = nodeFields.Count; i < n; i++)
            {
                var field = nodeFields[i];
                var directlyOverride = string.Compare(field.Override, "true", true) == 0;
                var overriddenName = field.IsOverride()
                    ? directlyOverride ? field.Name : field.Override
                    : field.Name;
                if (field.Type == "SyntaxToken")
                {
                    WriteComment(field.PropertyComment, "");
                    if (field.IsOverride() && !directlyOverride)
                    {
                        WriteLine($"public override {GetRedPropertyType(field)} {overriddenName} => this.{field.Name};");
                        Write($"public {GetRedPropertyType(field)} {field.Name}");
                    }
                    else
                        Write($"public {OverrideOrNewModifier(field)}{GetRedPropertyType(field)} {field.Name}");
                    if (field.IsOptional())
                    {
                        WriteLine();
                        this.OpenBlock();
                        WriteLine("get");
                        this.OpenBlock();
                        WriteLine($"var slot = ((Syntax.InternalSyntax.{node.Name})this.Green).{CamelCase(field.Name)};");
                        WriteLine($"return slot is not null ? new SyntaxToken(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;");
                        this.CloseBlock();
                        this.CloseBlock();
                    }
                    else
                    {
                        WriteLine($" => new SyntaxToken(this, ((Syntax.InternalSyntax.{node.Name})this.Green).{CamelCase(field.Name)}, {GetChildPosition(i)}, {GetChildIndex(i)});");
                    }
                }
                else if (field.Type == "SyntaxList<SyntaxToken>")
                {
                    WriteComment(field.PropertyComment, "");
                    if (field.IsOverride() && !directlyOverride)
                    {
                        WriteLine($"public override SyntaxTokenList {overriddenName} => this.{field.Name};");
                        Write($"public SyntaxTokenList {field.Name}");
                    }
                    else
                        WriteLine($"public {OverrideOrNewModifier(field)}SyntaxTokenList {field.Name}");
                    this.OpenBlock();
                    WriteLine("get");
                    this.OpenBlock();
                    WriteLine($"var slot = this.Green.GetSlot({i});");
                    WriteLine($"return slot is not null ? new SyntaxTokenList(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;");
                    this.CloseBlock();
                    this.CloseBlock();
                }
                else
                {
                    WriteComment(field.PropertyComment, "");
                    if (field.IsOverride() && !directlyOverride)
                    {
                        WriteLine($"public override {GetRedPropertyType(field)} {overriddenName} => this.{field.Name};");
                        Write($"public {GetRedPropertyType(field)} {field.Name}");
                    }
                    else
                        Write($"public {OverrideOrNewModifier(field)}{GetRedPropertyType(field)} {field.Name}");

                    if (field.IsNodeList)
                    {
                        WriteLine($" => new {field.Type}(GetRed(ref this.{CamelCase(field.Name)}, {i}));");
                    }
                    else if (field.IsSeparatedNodeList)
                    {
                        WriteLine();
                        this.OpenBlock();
                        WriteLine("get");
                        this.OpenBlock();

                        WriteLine($"var red = GetRed(ref this.{CamelCase(field.Name)}, {i});");
                        WriteLine($"return red is not null ? new {field.Type}(red, {GetChildIndex(i)}) : default;");
                        this.CloseBlock();
                        this.CloseBlock();
                    }
                    else if (field.Type == "SyntaxNodeOrTokenList")
                    {
                        throw new InvalidOperationException("field cannot be a random SyntaxNodeOrTokenList");
                    }
                    else
                    {
                        var suffix = field.IsOptional() ? "" : "!";
                        if (i == 0)
                        {
                            WriteLine($" => GetRedAtZero(ref this.{CamelCase(field.Name)}){suffix};");
                        }
                        else
                        {
                            WriteLine($" => GetRed(ref this.{CamelCase(field.Name)}, {i}){suffix};");
                        }
                    }
                }
                WriteLine();
            }

            foreach (var field in valueFields)
            {
                var directlyOverride = string.Compare(field.Override, "true", true) == 0;
                var overriddenName = field.IsOverride()
                    ? directlyOverride ? field.Name : field.Override
                    : field.Name;
                WriteComment(field.PropertyComment, "");
                if (field.IsOverride() && !directlyOverride)
                {
                    WriteLine($"public override {field.Type} {overriddenName} => this.{field.Name};");
                    WriteLine($"public {field.Type} {field.Name} => ((Syntax.InternalSyntax.{node.Name})this.Green).{field.Name};");
                }
                else
                    WriteLine($"public {OverrideOrNewModifier(field)}{field.Type} {field.Name} => ((Syntax.InternalSyntax.{node.Name})this.Green).{field.Name};");
                if (field.IsOverride() && !directlyOverride)
                    WriteLine($"public {field.Type} {field.Name} => ((Syntax.InternalSyntax.{node.Name})this.Green).{field.Name};");
                WriteLine();
            }

            {
                //GetNodeSlot forces creation of a red node.
                Write("internal override SyntaxNode? GetNodeSlot(int index)");

                var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                              .Where(t => t.field.Type is not "SyntaxToken" and not "SyntaxList<SyntaxToken>");
                if (!relevantNodes.Any())
                {
                    WriteLine(" => null;");
                }
                else if (relevantNodes.Count() == 1)
                {
                    var (field, index) = relevantNodes.Single();
                    var whenTrue = index == 0
                        ? $"GetRedAtZero(ref this.{CamelCase(field.Name)})"
                        : $"GetRed(ref this.{CamelCase(field.Name)}, {index})";

                    var suffix = field.IsOptional() ? "" : "!";
                    WriteLine($" => index == {index} ? {whenTrue}{suffix} : null;");
                }
                else
                {
                    WriteLine();
                    Indent();
                    WriteLine("=> index switch");
                    this.OpenBlock();
                    foreach (var (field, index) in relevantNodes)
                    {
                        var suffix = field.IsOptional() ? "" : "!";
                        if (index == 0)
                        {
                            WriteLine($"{index} => GetRedAtZero(ref this.{CamelCase(field.Name)}){suffix},");
                        }
                        else
                        {
                            WriteLine($"{index} => GetRed(ref this.{CamelCase(field.Name)}, {index}){suffix},");
                        }
                    }
                    WriteLine("_ => null,");
                    this.CloseBlock(";");
                    Unindent();
                }
            }

            WriteLine();

            {
                //GetCachedSlot returns a red node if we have it.
                Write("internal override SyntaxNode? GetCachedSlot(int index)");

                var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                              .Where(t => t.field.Type is not "SyntaxToken" and not "SyntaxList<SyntaxToken>");
                if (!relevantNodes.Any())
                {
                    WriteLine(" => null;");
                }
                else if (relevantNodes.Count() == 1)
                {
                    var (field, index) = relevantNodes.Single();
                    WriteLine($" => index == {index} ? this.{CamelCase(field.Name)} : null;");
                }
                else
                {
                    WriteLine();
                    Indent();
                    WriteLine("=> index switch");
                    this.OpenBlock();
                    foreach (var (field, index) in relevantNodes)
                    {
                        WriteLine($"{index} => this.{CamelCase(field.Name)},");
                    }
                    WriteLine("_ => null,");
                    this.CloseBlock(";");
                    Unindent();
                }
            }

            WriteRedAcceptMethods(nd);
            WriteRedUpdateMethod(nd);
            WriteRedWithMethods(nd);
            WriteRedListHelperMethods(nd);

            this.CloseBlock();
        }
    }

    private string GetRedFieldType(Field field)
    {
        if (field.Type == "SyntaxList<SyntaxToken>")
            return "SyntaxTokenList";

        if (field.IsOptional() && IsNode(field.Type) && field.Type != "SyntaxToken")
            return field.Type + "?";

        return field.Type;
    }

    private string GetChildPosition(int i)
        => i == 0 ? "Position" : "GetChildPosition(" + i + ")";

    private string GetChildIndex(int i)
        => i == 0 ? "0" : "GetChildIndex(" + i + ")";

    private void WriteRedAcceptMethods(Node node)
    {
        WriteLine();
        WriteRedAcceptMethod(node, false);
        WriteRedAcceptMethod(node, true);
    }

    private void WriteRedAcceptMethod(Node node, bool genericResult)
    {
        string genericArgs = genericResult ? "<TResult>" : "";
        WriteLine($"public override {(genericResult ? "TResult?" : "void")} Accept{genericArgs}({ThisLanguageName}SyntaxVisitor{genericArgs} visitor){(genericResult ? " where TResult : default" : "")} => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
    }

    private void WriteRedVisitors()
    {
        WriteRedVisitor(genericResult: true);
        WriteRedVisitor(genericResult: false);
    }

    private void WriteRedVisitor(bool genericResult)
    {
        string genericArgs = genericResult ? "<TResult>" : "";
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxVisitor{genericArgs}");
        this.OpenBlock();
        int nWritten = 0;
        foreach (var node in nodes.OfType<Node>())
        {
            if (nWritten > 0)
                WriteLine();
            nWritten++;
            WriteComment($"<summary>Called when the visitor visits a {node.Name} node.</summary>");
            WriteLine($"public virtual {(genericResult ? "TResult?" : "void")} Visit{StripPost(node.Name, "Syntax")}({node.Name} node) => this.DefaultVisit(node);");
        }
        this.CloseBlock();
    }

    private void WriteRedUpdateMethod(Node node)
    {
        WriteLine();
        Write($"public {node.Name} Update(");
        Write(CommaJoin(
            node.Fields.Select(f => $"{GetRedPropertyType(f)} {CamelCase(f.Name)}")));
        WriteLine(")");
        this.OpenBlock();

        Write("if (");
        int nCompared = 0;
        foreach (var field in node.Fields)
        {
            if (IsDerivedOrListOfDerived("SyntaxNode", field.Type) || IsDerivedOrListOfDerived("SyntaxToken", field.Type) || field.Type == "SyntaxNodeOrTokenList")
            {
                if (nCompared > 0)
                    Write(" || ");
                Write($"{CamelCase(field.Name)} != this.{field.Name}");
                nCompared++;
            }
        }
        if (nCompared > 0)
        {
            WriteLine(")");
            this.OpenBlock();
            Write($"var newNode = SyntaxFactory.{StripPost(node.Name, "Syntax")}(");
            Write(CommaJoin(
                node.Kinds.Count > 1 ? "this.Kind()" : "",
                node.Fields.Select(f => CamelCase(f.Name))));
            WriteLine(");");
            WriteLine("var annotations = GetAnnotations();");
            WriteLine("return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;");
            this.CloseBlock();
        }

        WriteLine();
        WriteLine("return this;");
        this.CloseBlock();
    }

    private void WriteRedWithMethods(Node node)
    {
        foreach (var field in node.Fields)
        {
            var type = GetRedPropertyType(field);

            if (field == node.Fields.First())
            {
                WriteLine();
            }

            var isNew = false;
            if (field.IsOverride())
            {
                var name = field.Name;
                var overriddenName = (string.Compare(field.Override, "true", true) == 0) ? name : field.Override!;
                var (baseType, baseField) = GetHighestBaseTypeWithField(node, overriddenName);
                if (baseType is not null)
                {
                    Write($"internal override {baseType.Name} With{overriddenName}Core({GetRedPropertyType(baseField!)} {CamelCase(overriddenName)}) => With{name}({CamelCase(overriddenName)}");
                    if (baseField!.Type != "SyntaxToken" && baseField.IsOptional() && !field.IsOptional())
                    {
                        Write($" ?? throw new ArgumentNullException(nameof({CamelCase(name)}))");
                    }
                    WriteLine(");");

                    isNew = true;
                }
            }

            Write(
                $"public{(isNew ? " new " : " ")}{node.Name} With{StripPost(field.Name, "Opt")}({type} {CamelCase(field.Name)})" +
                " => Update(");

            // call update inside each setter
            Write(CommaJoin(node.Fields.Select(f =>
                f == field ? CamelCase(f.Name) : $"this.{f.Name}")));
            WriteLine(");");
        }
    }

    private (SyntaxTreeType? type, Field? field) GetHighestBaseTypeWithField(SyntaxTreeType node, string name)
    {
        SyntaxTreeType? bestType = null;
        Field? bestField = null;
        for (var current = node; current is not null; current = TryGetBaseType(current))
        {
            var fields = GetNodeOrNodeListFields(current);
            var field = fields.FirstOrDefault(f => f.Name == name);
            if (field is not null)
            {
                bestType = current;
                bestField = field;
            }
        }

        return (bestType, bestField);
    }

    private SyntaxTreeType? TryGetBaseType(SyntaxTreeType node)
        => node is AbstractNode an
            ? GetTreeType(an.Base)
            : node is Node n
                ? GetTreeType(n.Base)
                : null;

    private void WriteRedListHelperMethods(Node node)
    {
        var wroteNewLine = false;
        foreach (var field in node.Fields)
        {
            if (field.Type.IsAnyList())
            {
                if (!wroteNewLine)
                {
                    WriteLine();
                    wroteNewLine = true;
                }
                // write list helper methods for list properties
                WriteRedListHelperMethods(node, field);
            }
            else
            {
                var referencedNode = TryGetNodeForNestedList(field);
                if (referencedNode is not null)
                {
                    // look for list members...
                    foreach (var referencedNodeField in referencedNode.Fields)
                    {
                        if (referencedNodeField.Type.IsAnyList())
                        {
                            if (!wroteNewLine)
                            {
                                WriteLine();
                                wroteNewLine = true;
                            }
                            WriteRedNestedListHelperMethods(node, field, referencedNode, referencedNodeField);
                        }
                    }
                }
            }
        }
    }

    private Node? TryGetNodeForNestedList(Field field)
    {
        var referencedNode = GetNode(field.Type);
        if (referencedNode is not null && (!field.IsOptional() || RequiredFactoryArgumentCount(referencedNode) == 0))
        {
            return referencedNode;
        }

        return null;
    }

    private void WriteRedListHelperMethods(Node node, Field field)
    {
        var argType = GetElementType(field.Type);

        var isNew = false;
        if (field.IsOverride())
        {
            var name = field.Name;
            var overriddenName = (string.Compare(field.Override, "true", true) == 0) ? name : field.Override!;
            var (baseType, baseField) = GetHighestBaseTypeWithField(node, overriddenName);
            if (baseType is not null)
            {
                var baseArgType = GetElementType(baseField!.Type);
                WriteLine($"internal override {baseType.Name} Add{overriddenName}Core(params {baseArgType}[] items) => Add{name}(items);");
                isNew = true;
            }
        }

        WriteLine($"public{(isNew ? " new " : " ")}{node.Name} Add{field.Name}(params {argType}[] items) => With{StripPost(field.Name, "Opt")}(this.{field.Name}.AddRange(items));");
    }

    private void WriteRedNestedListHelperMethods(Node node, Field field, Node referencedNode, Field referencedNodeField)
    {
        var argType = GetElementType(referencedNodeField.Type);

        var isNew = false;
        if (field.IsOverride())
        {
            var name = field.Name;
            var overriddenName = (string.Compare(field.Override, "true", true) == 0) ? name : field.Override!;
            var (baseType, _) = GetHighestBaseTypeWithField(node, overriddenName);
            if (baseType is not null)
            {
                WriteLine($"internal override {baseType.Name} Add{StripPost(overriddenName, "Opt")}{referencedNodeField.Name}Core(params {argType}[] items) => Add{StripPost(name, "Opt")}{referencedNodeField.Name}(items);");
                isNew = true;
            }
        }

        // AddBaseListTypes
        Write($"public{(isNew ? " new " : " ")}{node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items)");

        if (field.IsOptional())
        {
            WriteLine();
            this.OpenBlock();
            var factoryName = StripPost(referencedNode.Name, "Syntax");
            var varName = StripPost(CamelCase(field.Name), "Opt");
            WriteLine($"var {varName} = this.{field.Name} ?? SyntaxFactory.{factoryName}();");
            WriteLine($"return With{StripPost(field.Name, "Opt")}({varName}.With{StripPost(referencedNodeField.Name, "Opt")}({varName}.{referencedNodeField.Name}.AddRange(items)));");
            this.CloseBlock();
        }
        else
        {
            WriteLine($" => With{StripPost(field.Name, "Opt")}(this.{field.Name}.With{StripPost(referencedNodeField.Name, "Opt")}(this.{field.Name}.{referencedNodeField.Name}.AddRange(items)));");
        }
    }

    private void WriteRedRewriter()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode).ToList();

        WriteLine();
        WriteLine($"partial class {ThisLanguageName}SyntaxRewriter : {ThisLanguageName}SyntaxVisitor<SyntaxNode>");
        this.OpenBlock();

        int nWritten = 0;
        foreach (var node in nodes.OfType<Node>())
        {
            if (nWritten > 0)
                WriteLine();
            nWritten++;
            WriteLine($"public override SyntaxNode Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");

            if (node.Fields.Count == 0)
            {
                WriteLine("    => node;");
            }
            else
            {
                Write("    => node.Update(");
                Write(CommaJoin(node.Fields.Select(f =>
                {
                    if (IsNodeOrNodeList(f.Type))
                    {
                        if (f.Type.IsAnyList())
                            return $"VisitList(node.{f.Name})";
                        else if (f.Type == "SyntaxToken")
                            return $"VisitToken(node.{f.Name})";
                        else if (f.IsOptional())
                            return $"({(GetFieldType(f, green: false))})Visit(node.{f.Name})";
                        else
                            return $"({(GetFieldType(f, green: false))})Visit(node.{f.Name}) ?? throw new ArgumentNullException(\"{CamelCase(f.Name)}\")";
                    }

                    return $"node.{f.Name}";
                })));

                WriteLine(");");
            }
        }
        this.CloseBlock();
    }

    private void WriteRedFactories()
    {
        var nodes = Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).OfType<Node>().ToList();
        WriteLine();
        WriteLine("public static partial class SyntaxFactory");
        this.OpenBlock();

        foreach (var node in nodes)
        {
            WriteRedFactory(node);
            bool skipConvenienceFactories = node.SkipConvenienceFactories is not null && string.Compare(node.SkipConvenienceFactories, "true", true) == 0;
            if (!skipConvenienceFactories)
            {
                WriteRedFactoryWithNoAutoCreatableTokens(node);
                WriteRedMinimalFactory(node);
                WriteRedMinimalFactory(node, withStringNames: true);
            }
            WriteKindConverters(node);
        }

        this.CloseBlock();
    }

    protected bool CanBeAutoCreated(Node node, Field field)
        => IsAutoCreatableToken(node, field) || IsAutoCreatableNode(field);

    private bool IsAutoCreatableToken(Node node, Field field)
    {
        return field.Type == "SyntaxToken"
            && field.Kinds is not null
            && ((field.Kinds.Count == 1 && field.Kinds[0].Name != "IdentifierToken" && !field.Kinds[0].Name.EndsWith("LiteralToken", StringComparison.Ordinal)) || (field.Kinds.Count > 1 && field.Kinds.Count == node.Kinds.Count));
    }

    private bool IsAutoCreatableNode(Field field)
    {
        var referencedNode = GetNode(field.Type);
        return (referencedNode is not null && RequiredFactoryArgumentCount(referencedNode) == 0);
    }

    private bool IsRequiredFactoryField(Node node, Field field)
    {
        return (!field.IsOptional() && !field.Type.IsAnyList() && !CanBeAutoCreated(node, field)) || IsValueField(field);
    }

    private bool IsValueField(Field field)
    {
        return !IsNodeOrNodeList(field.Type);
    }

    private int RequiredFactoryArgumentCount(Node nd, bool includeKind = true)
    {
        int count = 0;

        // kind must be specified in factory
        if (nd.Kinds.Count > 1 && includeKind)
        {
            count++;
        }

        foreach (var field in nd.Fields)
        {
            if (IsRequiredFactoryField(nd, field))
            {
                count++;
            }
        }

        return count;
    }

    private int OptionalFactoryArgumentCount(Node nd)
    {
        int count = 0;
        foreach (var field in nd.Fields)
        {
            if (field.IsOptional() || CanBeAutoCreated(nd, field) || field.Type.IsAnyList())
            {
                count++;
            }
        }

        return count;
    }

    // full factory signature with nothing optional
    private void WriteRedFactory(Node nd)
    {
        WriteLine();

        var valueFields = nd.Fields.Where(IsValueField).ToList();
        var nodeFields = nd.Fields.Where(n => !IsValueField(n)).ToList();

        WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");

        Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
        WriteRedFactoryParameters(nd);

        WriteLine(")");
        this.OpenBlock();

        // validate kinds
        if (nd.Kinds.Count >= 2)
        {
            WriteLine("switch (kind)");
            this.OpenBlock();
            var kinds = nd.Kinds.Distinct().ToList();
            foreach (var kind in kinds)
            {
                WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");
            }
            WriteLine("default: throw new ArgumentException(nameof(kind));");
            this.CloseBlock();
        }

        // validate parameters
        foreach (var field in nodeFields)
        {
            var pname = CamelCase(field.Name);

            if (field.Type == "SyntaxToken")
            {
                var fieldKinds = GetKindsOfFieldOrNearestParent(nd, field);
                if (fieldKinds is not null && fieldKinds.Count > 0)
                {
                    var kinds = fieldKinds.ToList();
                    if (field.IsOptional())
                    {
                        kinds.Add(new Kind { Name = "None" });
                    }

                    if (kinds.Count == 1)
                    {
                        WriteLine($"if ({pname}.Kind() != SyntaxKind.{kinds[0].Name}) throw new ArgumentException(nameof({pname}));");
                    }
                    else
                    {
                        WriteLine($"switch ({pname}.Kind())");
                        this.OpenBlock();
                        foreach (var kind in kinds)
                        {
                            WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");
                        }
                        WriteLine($"default: throw new ArgumentException(nameof({pname}));");
                        this.CloseBlock();
                    }
                }
            }
            else if (!field.Type.IsAnyList() && !field.IsOptional())
            {
                WriteLine($"if ({CamelCase(field.Name)} is null) throw new ArgumentNullException(nameof({CamelCase(field.Name)}));");
            }
        }

        Write($"return ({nd.Name})Syntax.InternalSyntax.SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "kind" : "",
            nodeFields.Select(f =>
            {
                if (f.Type == "SyntaxToken")
                {
                    if (f.IsOptional())
                        return $"(Syntax.InternalSyntax.SyntaxToken?){CamelCase(f.Name)}.Node";
                    else
                        // We know the GreenNode is not null because it gets a type check earlier in the generated method
                        return $"(Syntax.InternalSyntax.SyntaxToken){CamelCase(f.Name)}.Node!";
                }
                else if (f.Type == "SyntaxList<SyntaxToken>")
                    return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()";
                else if (f.IsNodeList)
                    return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.{GetElementType(f.Type)}>()";
                else if (f.IsSeparatedNodeList)
                    return $"{CamelCase(f.Name)}.Node.ToGreenSeparatedList<Syntax.InternalSyntax.{GetElementType(f.Type)}>()";
                else if (f.Type == "SyntaxNodeOrTokenList")
                    return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.{ThisLanguageName}SyntaxNode>()";
                else if (f.IsOptional())
                    return $"{CamelCase(f.Name)} is null ? null : (Syntax.InternalSyntax.{f.Type}){CamelCase(f.Name)}.Green";
                else
                    return $"(Syntax.InternalSyntax.{f.Type}){CamelCase(f.Name)}.Green";
            }),
            // values are at end
            valueFields.Select(f => CamelCase(f.Name))));

        WriteLine(").CreateRed();");
        this.CloseBlock();
    }

    private void WriteRedFactoryParameters(Node nd)
    {
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "SyntaxKind kind" : "",
            nd.Fields.Select(f => $"{GetRedPropertyType(f)} {CamelCase(f.Name)}")));
    }

    private string GetRedPropertyType(Field field)
    {
        if (field.Type == "SyntaxList<SyntaxToken>")
            return "SyntaxTokenList";
        if (field.IsOptional() && IsNode(field.Type) && field.Type != "SyntaxToken")
            return field.Type + "?";
        return field.Type;
    }

    private string GetDefaultValue(Node nd, Field field)
    {
        Debug.Assert(!IsRequiredFactoryField(nd, field));

        if (field.IsOptional() || field.Type.IsAnyList())
        {
            var type = GetRedPropertyType(field);
            return type == "SyntaxTokenList" ? "default(SyntaxTokenList)" : "default";
        }
        else if (field.Type == "SyntaxToken")
        {
            // auto construct token?
            if (field.Kinds.Count == 1)
            {
                return $"SyntaxFactory.Token(SyntaxKind.{field.Kinds[0].Name})";
            }
            else
            {
                return $"SyntaxFactory.Token(Get{StripPost(nd.Name, "Syntax")}{StripPost(field.Name, "Opt")}Kind(kind))";
            }
        }
        else
        {
            var referencedNode = GetNode(field.Type)!;
            return $"SyntaxFactory.{StripPost(referencedNode.Name, "Syntax")}()";
        }
    }

    // Writes Get<Property>Kind() methods for converting between node kind and member token kinds...
    private void WriteKindConverters(Node nd)
    {
        foreach (var field in nd.Fields)
        {
            if (field.Type == "SyntaxToken" && CanBeAutoCreated(nd, field) && field.Kinds.Count > 1)
            {
                WriteLine();
                WriteLine($"private static SyntaxKind Get{StripPost(nd.Name, "Syntax")}{StripPost(field.Name, "Opt")}Kind(SyntaxKind kind)");
                Indent();
                WriteLine("=> kind switch");
                this.OpenBlock();

                for (int k = 0; k < field.Kinds.Count; k++)
                {
                    var nKind = nd.Kinds[k];
                    var pKind = field.Kinds[k];
                    WriteLine($"SyntaxKind.{nKind.Name} => SyntaxKind.{pKind.Name},");
                }

                WriteLine("_ => throw new ArgumentOutOfRangeException(),");
                this.CloseBlock(";");
                Unindent();
            }
        }
    }

    private IEnumerable<Field> DetermineRedFactoryWithNoAutoCreatableTokenFields(Node nd)
    {
        return nd.Fields.Where(f => !IsAutoCreatableToken(nd, f));
    }

    // creates a factory without auto-creatable token arguments
    private void WriteRedFactoryWithNoAutoCreatableTokens(Node nd)
    {
        var nAutoCreatableTokens = nd.Fields.Count(f => IsAutoCreatableToken(nd, f));
        if (nAutoCreatableTokens == 0)
            return; // already handled by general factory

        var factoryWithNoAutoCreatableTokenFields = new HashSet<Field>(DetermineRedFactoryWithNoAutoCreatableTokenFields(nd));
        var minimalFactoryFields = DetermineMinimalFactoryFields(nd);
        if (minimalFactoryFields is not null && factoryWithNoAutoCreatableTokenFields.SetEquals(minimalFactoryFields))
        {
            return; // will be handled in minimal factory case
        }

        WriteLine();

        WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");
        Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "SyntaxKind kind" : "",
            nd.Fields.Where(factoryWithNoAutoCreatableTokenFields.Contains).Select(
                f => $"{GetRedPropertyType(f)} {CamelCase(f.Name)}")));
        WriteLine(")");

        Write($"    => SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "kind" : "",
            nd.Fields.Select(f => factoryWithNoAutoCreatableTokenFields.Contains(f)
                ? CamelCase(f.Name)
                : GetDefaultValue(nd, f))));

        WriteLine(");");
    }

    private Field? DetermineMinimalOptionalField(Node nd)
    {
        // first if there is a single list, then choose the list because it would not have been optional
        int listCount = nd.Fields.Count(f => f.Type.IsAnyNodeList() && !IsAttributeOrModifiersList(f));
        if (listCount == 1)
        {
            return nd.Fields.First(f => f.Type.IsAnyNodeList() && !IsAttributeOrModifiersList(f));
        }
        else
        {
            // otherwise, if there is a single optional node, use that..
            int nodeCount = nd.Fields.Count(f => IsNode(f.Type) && f.Type != "SyntaxToken");
            if (nodeCount == 1)
            {
                return nd.Fields.First(f => IsNode(f.Type) && f.Type != "SyntaxToken");
            }
            else
            {
                return null;
            }
        }
    }

    private static bool IsAttributeOrModifiersList(Field f)
    {
        return f.Name is "AttributeLists" or "Modifiers";
    }

    private IEnumerable<Field>? DetermineMinimalFactoryFields(Node nd)
    {
        // special case to allow a single optional argument if there would have been no arguments
        // and we can determine a best single argument.
        Field? allowOptionalField = null;

        var optionalCount = OptionalFactoryArgumentCount(nd);
        if (optionalCount == 0)
        {
            return null; // no fields...
        }

        var requiredCount = RequiredFactoryArgumentCount(nd, includeKind: false);
        if (requiredCount == 0 && optionalCount > 1)
        {
            allowOptionalField = DetermineMinimalOptionalField(nd);
        }

        return nd.Fields.Where(f => IsRequiredFactoryField(nd, f) || allowOptionalField == f);
    }

    // creates a factory with only the required arguments (everything else is defaulted)
    private void WriteRedMinimalFactory(Node nd, bool withStringNames = false)
    {
        var optionalCount = OptionalFactoryArgumentCount(nd);
        if (optionalCount == 0)
            return; // already handled w/ general factory method

        var minimalFactoryfields = new HashSet<Field>(DetermineMinimalFactoryFields(nd));

        if (withStringNames && minimalFactoryfields.Count(f => IsRequiredFactoryField(nd, f) && CanAutoConvertFromString(f)) == 0)
            return; // no string-name overload necessary

        WriteLine();

        var hasOptional = minimalFactoryfields.Any(f => !IsRequiredFactoryField(nd, f));
        var hasAttributeOrModifiersList = nd.Fields.Any(IsAttributeOrModifiersList);

        if (hasOptional && hasAttributeOrModifiersList)
        {
            WriteLineWithoutIndent("#pragma warning disable RS0027");
        }

        WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");
        Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "SyntaxKind kind" : "",
            nd.Fields.Where(minimalFactoryfields.Contains).Select(f =>
            {
                var type = GetRedPropertyType(f);

                if (IsRequiredFactoryField(nd, f))
                {
                    if (withStringNames && CanAutoConvertFromString(f))
                        type = "string";

                    return $"{type} {CamelCase(f.Name)}";
                }
                else
                {
                    if (IsNode(f.Type) && !f.IsOptional() && f.Type != "SyntaxToken")
                        type += "?";

                    return $"{type} {CamelCase(f.Name)} = default";
                }
            })));
        WriteLine(")");

        Write($"    => SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");

        Write(CommaJoin(
            nd.Kinds.Count > 1 ? "kind" : "",
            nd.Fields.Select(f =>
            {
                if (minimalFactoryfields.Contains(f))
                {
                    if (IsRequiredFactoryField(nd, f))
                    {
                        if (withStringNames && CanAutoConvertFromString(f))
                            return $"{GetStringConverterMethod(f)}({CamelCase(f.Name)})";
                        else
                            return CamelCase(f.Name);
                    }
                    else
                    {
                        if (f.IsOptional() || f.Type.IsAnyList())
                            return CamelCase(f.Name);
                        else
                            return $"{CamelCase(f.Name)} ?? {GetDefaultValue(nd, f)}";
                    }
                }

                return GetDefaultValue(nd, f);
            })));

        WriteLine(");");

        if (hasOptional && hasAttributeOrModifiersList)
        {
            WriteLineWithoutIndent("#pragma warning restore RS0027");
        }
    }

    private bool CanAutoConvertFromString(Field field)
    {
        return IsIdentifierToken(field) || IsIdentifierNameSyntax(field);
    }

    private bool IsIdentifierToken(Field field)
    {
        return field.Type == "SyntaxToken" && field.Kinds is not null && field.Kinds.Count == 1 && field.Kinds[0].Name == "IdentifierToken";
    }

    private bool IsIdentifierNameSyntax(Field field)
    {
        return field.Type == "IdentifierNameSyntax";
    }

    private string GetStringConverterMethod(Field field)
    {
        if (IsIdentifierToken(field))
        {
            return "SyntaxFactory.Identifier";
        }
        else if (IsIdentifierNameSyntax(field))
        {
            return "SyntaxFactory.IdentifierName";
        }
        else
        {
            throw new NotSupportedException();
        }
    }

    /// <summary>
    /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
    /// XML doc comment.  Line breaks will be preserved.
    /// </summary>
    private void WriteComment(string comment)
    {
        if (comment is not null)
        {
            var lines = comment.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
            foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
            {
                WriteLine($"/// {line.TrimStart()}");
            }
        }
    }

    /// <summary>
    /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
    /// XML doc comment.  Line breaks will be preserved.
    /// </summary>
    private void WriteComment(Comment? comment, string indent)
    {
        if (comment is null) return;

        foreach (XmlElement element in comment.Body)
        {
            string[] lines = element.OuterXml.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
            {
                WriteLine($"{indent}/// {line.TrimStart()}");
            }
        }
    }
}
