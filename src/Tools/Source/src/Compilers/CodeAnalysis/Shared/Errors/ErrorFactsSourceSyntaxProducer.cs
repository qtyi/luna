// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Syntax;
using Roslyn.Utilities;

namespace Luna.Tools.ErrorFacts;

using static SyntaxFactory;

public sealed class ErrorFactsSourceSyntaxProducer : AbstractErrorFactsSourceSyntaxProducer
{
    protected override SyntaxTree Produce()
    {
        var root = CompilationUnit(
            externs: default,
            usings: default,
            attributeLists: default,
            members: SingletonList<MemberDeclarationSyntax>(ProduceNamespace()))
            .WithLeadingTrivia(
                Comment("// <auto-generated />"))
            .NormalizeWhitespace();

        return CSharpSyntaxTree.Create(root, encoding: Encoding.UTF8);
    }

    // namespace Qtyi.CodeAnalysis.[This]
    private FileScopedNamespaceDeclarationSyntax ProduceNamespace()
    {
        return FileScopedNamespaceDeclaration(
            attributeLists: default,
            modifiers: default,
            name: QualifiedName(QualifiedName(
                IdentifierName(Identifier_Qtyi),
                IdentifierName(Identifier_CodeAnalysis)),
                IdentifierName(_languageName)),
            externs: default,
            usings: default,
            members: SingletonList<MemberDeclarationSyntax>(ProduceClass()));
    }

    // partial class ErrorFacts
    private ClassDeclarationSyntax ProduceClass()
    {
        return ClassDeclaration(
            attributeLists: default,
            modifiers: TokenList(Token(SyntaxKind.PartialKeyword)),
            identifier: Identifier(Identifier_ErrorFacts),
            typeParameterList: null,
            baseList: null,
            constraintClauses: default,
            members: ProduceMethods());
    }

    private SyntaxList<MemberDeclarationSyntax> ProduceMethods()
    {
        var builder = SyntaxListBuilder<MemberDeclarationSyntax>.Create();

        foreach ((var category, var codeNames) in _errorCodeNames)
        {
            _cancellationToken.ThrowIfCancellationRequested();

            builder.Add(ProduceCategoryMethod(category, codeNames));
        }

        return builder.ToList();
    }

    // public static partial bool Is[Category](ErrorCode code)
    private static MethodDeclarationSyntax ProduceCategoryMethod(string category, ImmutableArray<string> codeNames)
    {
        var builder = SeparatedSyntaxListBuilder<SwitchExpressionArmSyntax>.Create();

        // ErrorCode.XXX or ... => true
        PatternSyntax? codesPattern = null;
        foreach (var name in codeNames)
        {
            var codePattern = ConstantPattern(QualifiedName(
                IdentifierName(Identifier_ErrorCode),
                IdentifierName(name)));
            if (codesPattern is null)
                codesPattern = codePattern;
            else
                codesPattern = BinaryPattern(
                    kind: SyntaxKind.OrPattern,
                    left: codesPattern,
                    right: codePattern);
        }
        if (codesPattern is not null)
        {
            builder.Add(SwitchExpressionArm(
                pattern: codesPattern,
                expression: LiteralExpression(SyntaxKind.TrueLiteralExpression)));
            builder.AddSeparator(Token(SyntaxKind.CommaToken));
        }

        // _ => false
        builder.Add(SwitchExpressionArm(
            pattern: DiscardPattern(),
            expression: LiteralExpression(SyntaxKind.FalseLiteralExpression)));

        // => code switch { ... }
        var switchExpression = SwitchExpression(
            governingExpression: IdentifierName("code"),
            arms: builder.ToList());

        return MethodDeclaration(
            attributeLists: default,
            modifiers: TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.PartialKeyword)),
            returnType: PredefinedType(Token(SyntaxKind.BoolKeyword)),
            explicitInterfaceSpecifier: null,
            identifier: Identifier($"Is{category}"),
            typeParameterList: null,
            parameterList: ParameterList(SingletonSeparatedList(
                Parameter(
                    attributeLists: default,
                    modifiers: default,
                    type: IdentifierName("ErrorCode"),
                    identifier: Identifier("code"),
                    @default: null))),
            constraintClauses: default,
            body: null,
            expressionBody: ArrowExpressionClause(switchExpression),
            semicolonToken: Token(SyntaxKind.SemicolonToken));
    }
}
