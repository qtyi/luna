// Licensed to the Qtyi under one or more agreements.
// The Qtyi licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Collections.Immutable;
using System.Diagnostics;
using Luna.Compilers.Generators.CompilationOptions.Model;
using Luna.Compilers.Generators.CSharp;
using Luna.Compilers.Generators.Model;
using Microsoft.CodeAnalysis;
using Roslyn.Utilities;
using LanguageNames = Qtyi.CodeAnalysis.LanguageNames;

namespace Luna.Compilers.Generators.CompilationOptions;

internal class CompilationOptionsSourceWriter : CompilationOptionsFileWriter
{
    protected Compilation Compilation { get; }

    public CompilationOptionsSourceWriter(TextWriter writer, OptionList tree, Compilation compilation, CancellationToken cancellationToken) : base(writer, tree, cancellationToken)
    {
        this.Compilation = compilation;
        this.BaseTypeOverrideInfo = GetBaseTypeOverrrideInfo(compilation);
    }

    public static void WriteMain(TextWriter writer, OptionList tree, Compilation compilation, CancellationToken cancellationToken = default) => new CompilationOptionsSourceWriter(writer, tree, compilation, cancellationToken).WriteMain();

    #region BaseTypeOverrideInfo
    protected readonly ImmutableDictionary<string, (IParameterSymbol ctorParam, IPropertySymbol prop, ImmutableArray<(IMethodSymbol method, IMethodSymbol commonMethod)> methodGroups)> BaseTypeOverrideInfo;

    private static ImmutableDictionary<string, (IParameterSymbol ctorParam, IPropertySymbol prop, ImmutableArray<(IMethodSymbol method, IMethodSymbol commonMethod)> methodGroups)> GetBaseTypeOverrrideInfo(Compilation compilation)
    {
        var dicBuilder = ImmutableDictionary.CreateBuilder<string, (IParameterSymbol ctorParam, IPropertySymbol prop, ImmutableArray<(IMethodSymbol method, IMethodSymbol commonMethod)> methodGroups)>(StringComparer.OrdinalIgnoreCase);

        var baseType = compilation.GetTypeByMetadataName(typeof(Microsoft.CodeAnalysis.CompilationOptions).FullName);
        Debug.Assert(baseType is not null);

        var constructor = baseType!.InstanceConstructors.SingleOrDefault(c => c.DeclaredAccessibility == Accessibility.Internal);
        Debug.Assert(constructor is not null);

        foreach (var param in constructor!.Parameters)
        {
            Debug.Assert(param.Name is not null);

            var prop = baseType.GetMembers().OfType<IPropertySymbol>().SingleOrDefault(p => !p.IsStatic && StringComparer.OrdinalIgnoreCase.Equals(p.Name, param.Name));
            Debug.Assert(prop is not null);

            if (prop!.Name is "WarningLevel" or "CurrentLocalTime" or "DebugPlusMode" or "ReferencesSupersedeLowerVersions")
            {
                dicBuilder.Add(prop.Name, (param, prop, default));
                continue;
            };

            var methodName = prop.Name == "CheckOverflow" ? "WithOverflowChecks" : "With" + prop.Name;
            var methods = baseType.GetMembers(methodName).OfType<IMethodSymbol>().Where(m => !m.IsStatic).ToImmutableArray();
            Debug.Assert(methods.Length != 0);

            var arrBuilder = ImmutableArray.CreateBuilder<(IMethodSymbol method, IMethodSymbol commonMethod)>();
            foreach (var method in methods)
            {
                Debug.Assert(method.Parameters.Length == 1);

                var commonMethodName = "CommonWith" + prop.Name;
                var commonMethod = baseType.GetMembers(commonMethodName).OfType<IMethodSymbol>().SingleOrDefault(m => !m.IsStatic && m.Parameters.Length == 1 && m.Parameters[0].Type.Equals(method.Parameters[0].Type));
                Debug.Assert(commonMethod is not null);

                arrBuilder.Add((method, commonMethod!));
            }
            dicBuilder.Add(prop.Name, (param, prop, arrBuilder.ToImmutable()));
        }

        return dicBuilder.ToImmutable();
    }
    #endregion

    private void WriteFileHeader()
    {
        this.WriteLine("// <auto-generated />");
        this.WriteLine();
        this.WriteLine("#nullable enable");
        this.WriteLine();
        this.WriteLine("using System;");
        this.WriteLine("using System.Collections.Generic;");
        this.WriteLine("using System.Collections.Immutable;");
        this.WriteLine("using Microsoft.CodeAnalysis;");
        this.WriteLine("using Microsoft.CodeAnalysis.PooledObjects;");
        this.WriteLine("using Roslyn.Utilities;");
        this.WriteLine();
    }

    private void WriteMain()
    {
        this.WriteFileHeader();
        this.WriteLine($"namespace Qtyi.CodeAnalysis.{LanguageNames.This}");
        this.OpenBlock();

        this.WriteLine($"partial class {LanguageNames.This}CompilationOptions");
        this.OpenBlock();

        this.WriteConstructors();
        this.WriteOptions();

        this.CloseBlock();

        this.CloseBlock();
    }

    private void WriteConstructors()
    {
        this.WriteInternalConstructor();
        this.WriteLine();
        this.WritePrivateConstructor();
    }

    private void WriteInternalConstructor()
    {
        this.WriteLine($"internal {LanguageNames.This}CompilationOptions(");
        this.Indent();
        var flag = false;
        foreach (var option in this.Tree.Options)
        {
            if (flag) WriteLine(",");
            else flag = true;

            if (this.BaseTypeOverrideInfo.TryGetValue(option.Base ?? option.Name, out var info))
            {
                var baseParam = info.ctorParam;
                this.Write(baseParam.Type.ToDisplayString((NullableFlowState)baseParam.Type.NullableAnnotation));
            }
            else
                this.Write("object?");
            this.Write(" ");
            this.Write(CamelCase(option.Name));
        }
        this.WriteLine(")");

        this.WriteLine(": base(");
        this.Indent();
        flag = false;
        foreach (var pair in this.BaseTypeOverrideInfo)
        {
            if (flag) WriteLine(",");
            else flag = true;

            var option = this.Tree.Options.SingleOrDefault(o => pair.Key == (o.Base ?? o.Name));
            this.Write($"{pair.Value.ctorParam.Name}: ");
            if (option is null)
                this.Write("default");
            else
                this.Write(CamelCase(option.Name));
        }
        this.WriteLine(")");
        this.Unindent();

        this.Unindent();
        this.OpenBlock();

        foreach (var option in this.Tree.Options)
        {
            if (!this.BaseTypeOverrideInfo.TryGetValue(option.Base ?? option.Name, out var _))
            {
                this.WriteLine($"this.{option.Name} = {CamelCase(option.Name)};");
            }
        }

        this.CloseBlock();
    }

    private void WritePrivateConstructor()
    {
        this.WriteLine($"private {LanguageNames.This}CompilationOptions({LanguageNames.This}CompilationOptions other) : this(");
        this.Indent();
        var flag = false;
        foreach (var option in this.Tree.Options)
        {
            if (flag) WriteLine(",");
            else flag = true;

            this.Write($"{CamelCase(option.Name)}: other.{option.Name}");
        }
        this.WriteLine(")");
        this.Unindent();

        this.OpenBlock();
        this.CloseBlock();
    }

    private void WriteOptions()
    {
        foreach (var option in this.Tree.Options)
        {
            this.WriteLine();
            if (this.BaseTypeOverrideInfo.TryGetValue(option.Base ?? option.Name, out var info))
            {
                if (option.Base is null || option.Base == option.Name)
                {
                    if (!info.methodGroups.IsDefaultOrEmpty)
                    {
                        foreach ((var method, var commonMethod) in info.methodGroups)
                        {
                            var paramNullableAnnotation = method.Parameters[0].NullableAnnotation;
                            var commonParamNullableAnnotation = commonMethod.Parameters[0].NullableAnnotation;
                            this.WriteWithMethod(option, info.prop.DeclaredAccessibility, info.prop.Type, info.prop.NullableAnnotation, method.Parameters[0].Type, (paramNullableAnnotation < commonParamNullableAnnotation ? commonParamNullableAnnotation : paramNullableAnnotation), isNew: true);
                            this.WriteCommonWithMethod(option, commonMethod.Parameters[0].Type, commonMethod.Parameters[0].NullableAnnotation);
                        }
                    }
                }
                else
                {
                    this.WriteProperty(option, info.prop);
                    if (!info.methodGroups.IsDefaultOrEmpty)
                    {
                        foreach ((var method, var commonMethod) in info.methodGroups)
                        {
                            var paramNullableAnnotation = method.Parameters[0].NullableAnnotation;
                            var commonParamNullableAnnotation = commonMethod.Parameters[0].NullableAnnotation;
                            this.WriteWithMethod(option, info.prop.DeclaredAccessibility, info.prop.Type, info.prop.NullableAnnotation, method.Parameters[0].Type, (paramNullableAnnotation < commonParamNullableAnnotation ? commonParamNullableAnnotation : paramNullableAnnotation), isNew: false);
                            this.WriteCommonWithMethod(option, commonMethod.Parameters[0].Type, commonMethod.Parameters[0].NullableAnnotation);
                        }
                    }
                }
            }
            else
            {
                this.WriteProperty(option);
                this.WriteWithMethods(option);
            }
        }

        foreach (var pair in this.BaseTypeOverrideInfo)
        {
            if (this.Tree.Options.Contains(o => (o.Base ?? o.Name) == pair.Key)) continue;

            var info = pair.Value;
            if (!info.methodGroups.IsDefaultOrEmpty)
            {
                foreach ((var _, var commonMethod) in info.methodGroups)
                {
                    this.WriteDefaultCommonWithMethod(commonMethod);
                }
            }
        }
    }

    private static string GetAccessibility(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",

        Accessibility.Internal or
        Accessibility.Friend => "internal",

        Accessibility.ProtectedOrInternal or
        Accessibility.ProtectedOrFriend => "protected internal",

        Accessibility.Protected => "protected",

        Accessibility.ProtectedAndInternal or
        Accessibility.ProtectedAndFriend => "private protected",

        Accessibility.Private => "private",

        _ => throw ExceptionUtilities.UnexpectedValue(accessibility)
    };

    private void WriteProperty(Option option)
    {
        this.WriteLine($"public object? {option.Name} {{ get; private set; }}");
    }

    private void WriteProperty(Option option, IPropertySymbol prop)
    {
        this.WriteLine($"{GetAccessibility(prop.DeclaredAccessibility)} {prop.Type.ToDisplayString((NullableFlowState)prop.NullableAnnotation)} {option.Name} {{ get => this.{option.Base ?? option.Name}; private set => this.{option.Base ?? option.Name} = value; }}");
    }

    private void WriteWithMethods(Option option)
    {
        this.WriteWithMethod(option, Accessibility.Public, this.Compilation.GetSpecialType(SpecialType.System_Object), NullableAnnotation.Annotated, this.Compilation.GetSpecialType(SpecialType.System_Object), NullableAnnotation.Annotated, isNew: false);
    }

    private void WriteWithMethod(Option option, Accessibility propAccessibility, ITypeSymbol propType, NullableAnnotation propNullableAnnotation, ITypeSymbol paramType, NullableAnnotation paramNullableAnnotation, bool isNew)
    {
        this.Write($"{GetAccessibility(propAccessibility)}{(isNew ? " new" : string.Empty)} {LanguageNames.This}CompilationOptions With{option.Name}({paramType.ToDisplayString((NullableFlowState)(propType.Equals(paramType) ? (paramNullableAnnotation < propNullableAnnotation ? propNullableAnnotation : paramNullableAnnotation) : paramNullableAnnotation))} value)");

        var immutableArrayType = this.Compilation.GetTypeByMetadataName(typeof(ImmutableArray<>).FullName)?.OriginalDefinition;
        Debug.Assert(immutableArrayType is not null);
        var immutableDictionaryType = this.Compilation.GetTypeByMetadataName(typeof(ImmutableDictionary<,>).FullName)?.OriginalDefinition;
        Debug.Assert(immutableDictionaryType is not null);
        var iEnumerableType = this.Compilation.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T);
        var keyValuePairType = this.Compilation.GetTypeByMetadataName(typeof(KeyValuePair<,>).FullName)?.OriginalDefinition;
        Debug.Assert(keyValuePairType is not null);
        var assemblyIdentityComparerType = this.Compilation.GetTypeByMetadataName(typeof(AssemblyIdentityComparer).FullName);
        Debug.Assert(assemblyIdentityComparerType is not null);
        if (!propType.Equals(paramType))
        {
            this.Write(" => ");
            if (propType.OriginalDefinition.Equals(immutableArrayType))
            {
                var propTypeInner = ((INamedTypeSymbol)propType).TypeArguments[0];
                var propTypeInnerNullableAnnotation = ((INamedTypeSymbol)propType).TypeArgumentNullableAnnotations[0];
                if (paramType is IArrayTypeSymbol)
                {
                    var paramTypeInner = ((IArrayTypeSymbol)paramType).ElementType;
                    var paramTypeInnerNullableAnnotation = ((IArrayTypeSymbol)paramType).ElementNullableAnnotation;
                    Debug.Assert(propTypeInner.Equals(paramTypeInner) && propTypeInnerNullableAnnotation == paramTypeInnerNullableAnnotation);

                    this.Write($"this.With{option.Name}((");
                    this.Write(iEnumerableType.Construct(ImmutableArray.Create(propTypeInner), ImmutableArray.Create(propTypeInnerNullableAnnotation)).ToDisplayString((NullableFlowState)paramNullableAnnotation));
                    this.WriteLine(")value);");

                    return;
                }
                else if (paramType.OriginalDefinition.Equals(iEnumerableType))
                {
                    var paramTypeInner = ((INamedTypeSymbol)paramType).TypeArguments[0];
                    var paramTypeInnerNullableAnnotation = ((INamedTypeSymbol)paramType).TypeArgumentNullableAnnotations[0];
                    Debug.Assert(propTypeInner.Equals(paramTypeInner) && propTypeInnerNullableAnnotation == paramTypeInnerNullableAnnotation);

                    this.Write($"new {LanguageNames.This}CompilationOptions(this) {{ {option.Name} = value.AsImmutableOrEmpty() }};");

                    return;
                }
            }
            else if (propType.OriginalDefinition.Equals(immutableDictionaryType))
            {
                var propTypeInners = ((INamedTypeSymbol)propType).TypeArguments;
                var propTypeInnerNullableAnnotations = ((INamedTypeSymbol)propType).TypeArgumentNullableAnnotations;
                if (paramType.OriginalDefinition.Equals(iEnumerableType))
                {
                    Debug.Assert(((INamedTypeSymbol)paramType).TypeArguments[0].OriginalDefinition.Equals(keyValuePairType));
                    var paramTypeInners = ((INamedTypeSymbol)((INamedTypeSymbol)paramType).TypeArguments[0]).TypeArguments;
                    var paramTypeInnerNullableAnnotations = ((INamedTypeSymbol)((INamedTypeSymbol)paramType).TypeArguments[0]).TypeArgumentNullableAnnotations;
                    Debug.Assert(propTypeInners.SequenceEqual(paramTypeInners) && propTypeInnerNullableAnnotations.SequenceEqual(paramTypeInnerNullableAnnotations));

                    this.Write($"new {LanguageNames.This}CompilationOptions(this) {{ {option.Name} = value.ToImmutableDictionaryOrEmpty() }};");

                    return;
                }
            }

            this.WriteLine($"this.With{option.Name}(value);");

            return;
        }
        else
        {
            this.WriteLine();
            this.OpenBlock();

            if (paramType.SpecialType == SpecialType.System_String)
            {
                this.WriteLine("if (string.IsNullOrEmpty(value))");
                this.OpenBlock();
                this.WriteLine("value = null;");
                this.CloseBlock();

                this.WriteLine();
            }
            else if (paramType.OriginalDefinition.Equals(immutableArrayType))
            {
                this.WriteLine("if (value.IsDefault)");
                this.OpenBlock();
                this.WriteLine($"value = {paramType.ToDisplayString(NullableFlowState.NotNull)}.Empty;");
                this.CloseBlock();

                this.WriteLine();
            }
            else if (paramType.OriginalDefinition.Equals(immutableDictionaryType))
            {
                this.WriteLine("if (value is null)");
                this.OpenBlock();
                this.WriteLine($"value = {paramType.ToDisplayString(NullableFlowState.NotNull)}.Empty;");
                this.CloseBlock();

                this.WriteLine();
            }
            else if (paramType.Equals(assemblyIdentityComparerType))
            {
                this.WriteLine($"value ??= {assemblyIdentityComparerType.ToDisplayString(NullableFlowState.NotNull)}.Default;");

                this.WriteLine();
            }

            this.Write("if (");
            if (paramType.SpecialType is SpecialType.System_Enum or
                (> SpecialType.System_Boolean and < SpecialType.System_UIntPtr) or
                SpecialType.System_Nullable_T or
                SpecialType.System_DateTime)
            {
                this.Write($"value == this.{option.Name}");
            }
            else if (paramType.OriginalDefinition.Equals(immutableArrayType) ||
                paramType.OriginalDefinition.Equals(immutableDictionaryType))
            {
                this.Write($"value == this.{option.Name}");
            }
            else if (paramType.IsValueType)
            {
                this.Write($"value == this.{option.Name}");
            }
            else
            {
                this.Write($"object.ReferenceEquals(value, this.{option.Name})");
            }
            this.WriteLine(")");
            this.OpenBlock();
            this.WriteLine("return this;");
            this.CloseBlock();

            this.WriteLine();

            this.WriteLine($"return new {LanguageNames.This}CompilationOptions(this) {{ {option.Name} = value }};");

            this.CloseBlock();
        }
    }

    private void WriteCommonWithMethod(Option option, ITypeSymbol type, NullableAnnotation nullableAnnotation)
    {
        this.WriteLine($"protected override CompilationOptions CommonWith{option.Base ?? option.Name}({type.ToDisplayString((NullableFlowState)nullableAnnotation)} {CamelCase(option.Base ?? option.Name)}) => this.With{option.Name}({CamelCase(option.Base ?? option.Name)});");
    }

    private void WriteDefaultCommonWithMethod(IMethodSymbol method)
    {
        var param = method.Parameters[0];
        this.WriteLine($"{GetAccessibility(method.DeclaredAccessibility)} override CompilationOptions {method.Name}({param.Type.ToDisplayString((NullableFlowState)param.NullableAnnotation)} {param.Name}) => this;");
    }
}
